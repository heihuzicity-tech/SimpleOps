# 多标签页连接工作台详细开发计划

## 📅 项目总体时间安排

- **总工期**: 15-18 个工作日
- **开始时间**: 2025-07-17
- **预计完成**: 2025-08-08
- **开发模式**: 迭代式开发，每个阶段可独立测试验证

---

## 🚀 第一阶段：基础架构搭建

**时间**: 第1-4工作日 (7月17日-7月22日)  
**目标**: 完成基础布局和核心组件架构  
**可交付成果**: 可运行的基础工作台页面

### Day 1: 项目初始化和基础布局

#### 任务清单
- [ ] **创建基础目录结构**
  ```bash
  mkdir -p frontend/src/components/workspace
  mkdir -p frontend/src/pages/connect
  mkdir -p frontend/src/store/workspace
  mkdir -p frontend/src/types/workspace
  ```

- [ ] **创建基础布局组件**
  - 文件: `frontend/src/pages/connect/WorkspaceLayout.tsx`
  - 功能: 实现左右分栏布局
  - 技术: Ant Design Layout + Splitter

- [ ] **定义类型接口**
  - 文件: `frontend/src/types/workspace.ts`
  - 内容: TabInfo, WorkspaceState, SessionState 等核心类型

#### 具体实现代码示例
```typescript
// frontend/src/types/workspace.ts
export interface TabInfo {
  id: string;
  title: string;
  type: 'ssh' | 'database' | 'rdp';
  sessionId?: string;
  assetInfo: {
    id: number;
    name: string;
    address: string;
    port: number;
    protocol: string;
  };
  credentialInfo: {
    id: number;
    username: string;
    type: string;
  };
  closable: boolean;
  modified: boolean;
  connectionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error';
  createdAt: Date;
  lastActivity: Date;
}

export interface WorkspaceState {
  tabs: TabInfo[];
  activeTabId: string;
  sidebarWidth: number;
  sidebarCollapsed: boolean;
  layout: 'horizontal' | 'vertical';
}
```

#### 验收标准
- [ ] 页面可以正常访问 `/connect/workspace`
- [ ] 左右分栏布局正常显示
- [ ] 可以拖拽调整侧边栏宽度
- [ ] 响应式布局在不同屏幕尺寸下正常工作

### Day 2: 侧边栏组件集成

#### 任务清单
- [ ] **集成ResourceTree组件**
  - 修改现有ResourceTree组件适配新布局
  - 添加工作台专用的交互逻辑

- [ ] **创建SidePanel组件**
  - 文件: `frontend/src/components/workspace/SidePanel.tsx`
  - 功能: 集成资源树、搜索、历史记录

- [ ] **实现基础交互**
  - 资源树选择事件处理
  - 搜索功能集成
  - 折叠/展开功能

#### 具体实现代码示例
```typescript
// frontend/src/components/workspace/SidePanel.tsx
import React, { useState } from 'react';
import { Card, Tabs, Input, List, Button } from 'antd';
import { SearchOutlined, HistoryOutlined, FolderOutlined } from '@ant-design/icons';
import ResourceTree from '../sessions/ResourceTree';

const { TabPane } = Tabs;
const { Search } = Input;

interface SidePanelProps {
  width: number;
  collapsed: boolean;
  onAssetSelect: (asset: any) => void;
  onToggleCollapse: () => void;
}

const SidePanel: React.FC<SidePanelProps> = ({
  width,
  collapsed,
  onAssetSelect,
  onToggleCollapse
}) => {
  const [activeTab, setActiveTab] = useState('resources');
  const [searchValue, setSearchValue] = useState('');

  return (
    <div style={{ width: collapsed ? 50 : width, transition: 'width 0.3s' }}>
      {!collapsed && (
        <Card size="small" style={{ height: '100%' }}>
          <Tabs activeKey={activeTab} onChange={setActiveTab} size="small">
            <TabPane tab={<><FolderOutlined />资源</>} key="resources">
              <Search
                placeholder="搜索资源"
                value={searchValue}
                onChange={(e) => setSearchValue(e.target.value)}
                style={{ marginBottom: 8 }}
                prefix={<SearchOutlined />}
              />
              <ResourceTree
                onSelect={onAssetSelect}
                resourceType="host"
                searchValue={searchValue}
              />
            </TabPane>
            <TabPane tab={<><HistoryOutlined />历史</>} key="history">
              <List
                size="small"
                dataSource={[]}
                renderItem={(item) => (
                  <List.Item>
                    <Button type="link" size="small">
                      {item.name}
                    </Button>
                  </List.Item>
                )}
              />
            </TabPane>
          </Tabs>
        </Card>
      )}
    </div>
  );
};

export default SidePanel;
```

#### 验收标准
- [ ] 侧边栏可以正常切换标签页（资源/历史）
- [ ] 资源树选择功能正常
- [ ] 搜索功能可以过滤资源
- [ ] 折叠/展开动画流畅

### Day 3: 标签页容器组件

#### 任务清单
- [ ] **创建TabContainer组件**
  - 文件: `frontend/src/components/workspace/TabContainer.tsx`
  - 功能: 标签页的容器和基础管理

- [ ] **实现标签页头部**
  - 标签页标题显示
  - 关闭按钮
  - 连接状态指示

- [ ] **创建空状态页面**
  - 当没有标签页时显示的欢迎页面
  - 快速连接入口

#### 具体实现代码示例
```typescript
// frontend/src/components/workspace/TabContainer.tsx
import React from 'react';
import { Tabs, Button, Empty, Typography } from 'antd';
import { PlusOutlined, CloseOutlined } from '@ant-design/icons';
import { TabInfo } from '../../types/workspace';

const { TabPane } = Tabs;
const { Title, Paragraph } = Typography;

interface TabContainerProps {
  tabs: TabInfo[];
  activeTabId: string;
  onTabChange: (tabId: string) => void;
  onTabClose: (tabId: string) => void;
  onNewTab: () => void;
}

const TabContainer: React.FC<TabContainerProps> = ({
  tabs,
  activeTabId,
  onTabChange,
  onTabClose,
  onNewTab
}) => {
  const renderTabTitle = (tab: TabInfo) => (
    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
      <StatusIndicator status={tab.connectionStatus} />
      <span>{tab.title}</span>
      {tab.closable && (
        <Button
          type="text"
          size="small"
          icon={<CloseOutlined />}
          onClick={(e) => {
            e.stopPropagation();
            onTabClose(tab.id);
          }}
          style={{ marginLeft: 4 }}
        />
      )}
    </div>
  );

  const renderEmptyState = () => (
    <div style={{ 
      height: '100%', 
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center' 
    }}>
      <Empty
        description={
          <div>
            <Title level={4}>欢迎使用连接工作台</Title>
            <Paragraph>
              从左侧选择主机资源开始连接，或者点击下方按钮创建新的连接
            </Paragraph>
            <Button type="primary" icon={<PlusOutlined />} onClick={onNewTab}>
              新建连接
            </Button>
          </div>
        }
      />
    </div>
  );

  if (tabs.length === 0) {
    return renderEmptyState();
  }

  return (
    <Tabs
      type="editable-card"
      activeKey={activeTabId}
      onChange={onTabChange}
      onEdit={(targetKey, action) => {
        if (action === 'remove') {
          onTabClose(targetKey as string);
        }
      }}
      hideAdd
      style={{ height: '100%' }}
    >
      {tabs.map(tab => (
        <TabPane
          key={tab.id}
          tab={renderTabTitle(tab)}
          closable={tab.closable}
        >
          <div style={{ height: 'calc(100vh - 120px)' }}>
            {/* 这里后续会放置 WebTerminal 组件 */}
            <div>终端内容区域 - {tab.title}</div>
          </div>
        </TabPane>
      ))}
    </Tabs>
  );
};

// 连接状态指示器
const StatusIndicator: React.FC<{ status: TabInfo['connectionStatus'] }> = ({ status }) => {
  const getStatusColor = () => {
    switch (status) {
      case 'connected': return '#52c41a';
      case 'connecting': return '#1890ff';
      case 'disconnected': return '#d9d9d9';
      case 'error': return '#ff4d4f';
      default: return '#d9d9d9';
    }
  };

  return (
    <div
      style={{
        width: 8,
        height: 8,
        borderRadius: '50%',
        backgroundColor: getStatusColor(),
        display: 'inline-block'
      }}
    />
  );
};

export default TabContainer;
```

#### 验收标准
- [ ] 空状态页面正常显示
- [ ] 标签页头部样式正确
- [ ] 连接状态指示器颜色正确
- [ ] 标签页切换功能正常

### Day 4: 路由配置和基础集成

#### 任务清单
- [ ] **配置新路由**
  - 更新 `App.tsx` 添加工作台路由
  - 添加权限控制

- [ ] **集成现有组件**
  - 将新页面集成到现有应用中
  - 确保样式一致性

- [ ] **基础功能测试**
  - 页面加载测试
  - 布局响应测试
  - 基础交互测试

#### 路由配置示例
```typescript
// frontend/src/App.tsx (更新部分)
import WorkspaceLayout from './pages/connect/WorkspaceLayout';

// 在路由配置中添加
<Route 
  path="/connect/workspace" 
  element={
    <PermissionGuard requiredRole={['admin', 'operator', 'user']}>
      <WorkspaceLayout />
    </PermissionGuard>
  } 
/>
```

#### 验收标准
- [ ] 新路由可以正常访问
- [ ] 权限控制正常工作
- [ ] 页面样式与现有应用一致
- [ ] 第一阶段功能演示可以通过

---

## 🔧 第二阶段：标签页系统实现

**时间**: 第5-9工作日 (7月23日-7月29日)  
**目标**: 完成标签页的完整生命周期管理  
**可交付成果**: 可以创建、管理和切换标签页

### Day 5: 状态管理实现

#### 任务清单
- [ ] **创建 workspaceSlice**
  - 文件: `frontend/src/store/workspaceSlice.ts`
  - 功能: 标签页状态管理

- [ ] **定义 Actions 和 Reducers**
  - 标签页增删改查
  - 状态更新逻辑

- [ ] **集成到全局 store**
  - 更新 `store/index.ts`
  - 类型定义更新

#### 具体实现代码示例
```typescript
// frontend/src/store/workspaceSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { TabInfo, WorkspaceState } from '../types/workspace';
import { nanoid } from 'nanoid';

const initialState: WorkspaceState = {
  tabs: [],
  activeTabId: '',
  sidebarWidth: 280,
  sidebarCollapsed: false,
  layout: 'horizontal'
};

// 异步创建新标签页
export const createNewTab = createAsyncThunk(
  'workspace/createNewTab',
  async (params: { assetInfo: any; credentialInfo: any }) => {
    const { assetInfo, credentialInfo } = params;
    
    const tabId = nanoid();
    const tab: TabInfo = {
      id: tabId,
      title: `${assetInfo.name} (${credentialInfo.username})`,
      type: 'ssh',
      assetInfo,
      credentialInfo,
      closable: true,
      modified: false,
      connectionStatus: 'idle',
      createdAt: new Date(),
      lastActivity: new Date()
    };
    
    return tab;
  }
);

// 创建会话连接
export const connectTab = createAsyncThunk(
  'workspace/connectTab',
  async (params: { tabId: string; connectionParams: any }) => {
    const { tabId, connectionParams } = params;
    
    // 调用现有的 SSH 连接 API
    const response = await sshAPI.createSession(connectionParams);
    
    return {
      tabId,
      sessionId: response.id,
      connectionStatus: 'connected' as const
    };
  }
);

const workspaceSlice = createSlice({
  name: 'workspace',
  initialState,
  reducers: {
    // 添加标签页
    addTab: (state, action: PayloadAction<TabInfo>) => {
      state.tabs.push(action.payload);
      state.activeTabId = action.payload.id;
    },
    
    // 关闭标签页
    closeTab: (state, action: PayloadAction<string>) => {
      const tabIndex = state.tabs.findIndex(tab => tab.id === action.payload);
      if (tabIndex !== -1) {
        state.tabs.splice(tabIndex, 1);
        
        // 如果关闭的是当前活跃标签页，切换到其他标签页
        if (state.activeTabId === action.payload) {
          if (state.tabs.length > 0) {
            const newActiveIndex = Math.max(0, tabIndex - 1);
            state.activeTabId = state.tabs[newActiveIndex]?.id || '';
          } else {
            state.activeTabId = '';
          }
        }
      }
    },
    
    // 切换活跃标签页
    setActiveTab: (state, action: PayloadAction<string>) => {
      state.activeTabId = action.payload;
    },
    
    // 更新标签页状态
    updateTabStatus: (state, action: PayloadAction<{ tabId: string; status: TabInfo['connectionStatus'] }>) => {
      const tab = state.tabs.find(t => t.id === action.payload.tabId);
      if (tab) {
        tab.connectionStatus = action.payload.status;
        tab.lastActivity = new Date();
      }
    },
    
    // 更新标签页标题
    updateTabTitle: (state, action: PayloadAction<{ tabId: string; title: string }>) => {
      const tab = state.tabs.find(t => t.id === action.payload.tabId);
      if (tab) {
        tab.title = action.payload.title;
        tab.modified = true;
      }
    },
    
    // 设置侧边栏宽度
    setSidebarWidth: (state, action: PayloadAction<number>) => {
      state.sidebarWidth = action.payload;
    },
    
    // 切换侧边栏折叠状态
    toggleSidebarCollapsed: (state) => {
      state.sidebarCollapsed = !state.sidebarCollapsed;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(createNewTab.fulfilled, (state, action) => {
        state.tabs.push(action.payload);
        state.activeTabId = action.payload.id;
      })
      .addCase(connectTab.pending, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.meta.arg.tabId);
        if (tab) {
          tab.connectionStatus = 'connecting';
        }
      })
      .addCase(connectTab.fulfilled, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.payload.tabId);
        if (tab) {
          tab.sessionId = action.payload.sessionId;
          tab.connectionStatus = action.payload.connectionStatus;
        }
      })
      .addCase(connectTab.rejected, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.meta.arg.tabId);
        if (tab) {
          tab.connectionStatus = 'error';
        }
      });
  }
});

export const {
  addTab,
  closeTab,
  setActiveTab,
  updateTabStatus,
  updateTabTitle,
  setSidebarWidth,
  toggleSidebarCollapsed
} = workspaceSlice.actions;

export default workspaceSlice.reducer;
```

#### 验收标准
- [ ] 状态管理正常工作
- [ ] 标签页增删改查功能正常
- [ ] Redux DevTools 可以查看状态变化
- [ ] 类型检查通过

### Day 6: 凭证选择和连接创建

#### 任务清单
- [ ] **实现连接创建流程**
  - 从资源树选择主机
  - 弹出凭证选择对话框
  - 创建新标签页

- [ ] **集成CredentialSelector组件**
  - 复用现有的凭证选择组件
  - 适配工作台场景

- [ ] **连接状态管理**
  - 连接过程状态显示
  - 错误处理和重试机制

#### 具体实现代码示例
```typescript
// frontend/src/components/workspace/ConnectionCreator.tsx
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { Modal, message } from 'antd';
import CredentialSelector from '../sessions/CredentialSelector';
import { createNewTab, connectTab } from '../../store/workspaceSlice';
import { performConnectionTest } from '../../services/connectionTest';

interface ConnectionCreatorProps {
  visible: boolean;
  selectedAsset: any;
  credentials: any[];
  onClose: () => void;
}

const ConnectionCreator: React.FC<ConnectionCreatorProps> = ({
  visible,
  selectedAsset,
  credentials,
  onClose
}) => {
  const dispatch = useDispatch();
  const [connecting, setConnecting] = useState(false);

  const handleCredentialSelect = async (credentialId: number) => {
    if (!selectedAsset) return;
    
    setConnecting(true);
    
    try {
      // 先进行连接测试
      const testResult = await performConnectionTest(dispatch, selectedAsset, credentialId);
      
      if (!testResult.success) {
        setConnecting(false);
        return;
      }
      
      // 创建新标签页
      const credential = credentials.find(c => c.id === credentialId);
      const newTabAction = await dispatch(createNewTab({
        assetInfo: selectedAsset,
        credentialInfo: credential
      }));
      
      if (createNewTab.fulfilled.match(newTabAction)) {
        const tab = newTabAction.payload;
        
        // 创建连接
        await dispatch(connectTab({
          tabId: tab.id,
          connectionParams: {
            asset_id: selectedAsset.id,
            credential_id: credentialId,
            protocol: selectedAsset.protocol || 'ssh',
            width: 80,
            height: 24
          }
        }));
        
        message.success(`成功连接到 ${selectedAsset.name}`);
        onClose();
      }
    } catch (error: any) {
      message.error(`连接失败: ${error.message}`);
    } finally {
      setConnecting(false);
    }
  };

  return (
    <CredentialSelector
      visible={visible}
      onCancel={onClose}
      onSelect={handleCredentialSelect}
      asset={selectedAsset}
      credentials={credentials}
      loading={connecting}
    />
  );
};

export default ConnectionCreator;
```

#### 验收标准
- [ ] 从资源树选择主机后弹出凭证选择
- [ ] 选择凭证后能成功创建标签页
- [ ] 连接测试功能正常
- [ ] 错误处理和用户反馈正常

### Day 7: WebTerminal 组件集成

#### 任务清单
- [ ] **修改 WebTerminal 组件**
  - 适配工作台环境
  - 支持多实例同时运行

- [ ] **创建 ConnectionPanel 组件**
  - 封装 WebTerminal
  - 添加连接管理功能

- [ ] **实现终端生命周期管理**
  - 创建、激活、销毁
  - 资源清理

#### 具体实现代码示例
```typescript
// frontend/src/components/workspace/ConnectionPanel.tsx
import React, { useEffect, useRef } from 'react';
import { useDispatch } from 'react-redux';
import { message } from 'antd';
import WebTerminal from '../ssh/WebTerminal';
import { updateTabStatus } from '../../store/workspaceSlice';
import { TabInfo } from '../../types/workspace';

interface ConnectionPanelProps {
  tab: TabInfo;
  isActive: boolean;
  onClose: () => void;
}

const ConnectionPanel: React.FC<ConnectionPanelProps> = ({
  tab,
  isActive,
  onClose
}) => {
  const dispatch = useDispatch();
  const terminalRef = useRef<any>(null);

  // 处理连接状态变化
  const handleConnectionStatusChange = (status: 'connected' | 'connecting' | 'disconnected' | 'error') => {
    dispatch(updateTabStatus({ tabId: tab.id, status }));
  };

  // 处理终端错误
  const handleError = (error: Error) => {
    console.error(`Terminal error for tab ${tab.id}:`, error);
    dispatch(updateTabStatus({ tabId: tab.id, status: 'error' }));
    message.error(`连接错误: ${error.message}`);
  };

  // 处理终端关闭
  const handleClose = () => {
    onClose();
  };

  // 当标签页激活时，调整终端大小
  useEffect(() => {
    if (isActive && terminalRef.current) {
      // 延迟调整大小，确保DOM已更新
      setTimeout(() => {
        terminalRef.current?.fit();
      }, 100);
    }
  }, [isActive]);

  // 如果没有会话ID，显示连接中状态
  if (!tab.sessionId) {
    return (
      <div style={{ 
        height: '100%', 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center' 
      }}>
        <div>正在建立连接...</div>
      </div>
    );
  }

  return (
    <div style={{ height: '100%', position: 'relative' }}>
      <WebTerminal
        ref={terminalRef}
        sessionId={tab.sessionId}
        onClose={handleClose}
        onError={handleError}
        onStatusChange={handleConnectionStatusChange}
        // 只有活跃标签页才启用终端
        disabled={!isActive}
      />
    </div>
  );
};

export default ConnectionPanel;
```

#### 验收标准
- [ ] WebTerminal 在标签页中正常工作
- [ ] 多个终端可以同时存在
- [ ] 切换标签页时终端正常显示
- [ ] 终端大小自动调整

### Day 8: 标签页操作功能

#### 任务清单
- [ ] **实现标签页右键菜单**
  - 关闭、关闭其他、关闭全部
  - 重命名标签页
  - 复制连接信息

- [ ] **添加标签页快捷操作**
  - 双击重命名
  - 中键关闭
  - 键盘快捷键

- [ ] **实现标签页拖拽排序**
  - 使用 react-sortable-hoc 或类似库
  - 拖拽视觉反馈

#### 具体实现代码示例
```typescript
// frontend/src/components/workspace/TabContextMenu.tsx
import React from 'react';
import { Menu, Dropdown } from 'antd';
import { 
  CloseOutlined, 
  EditOutlined, 
  CopyOutlined,
  CloseCircleOutlined,
  MinusCircleOutlined 
} from '@ant-design/icons';

interface TabContextMenuProps {
  tabId: string;
  onClose: (tabId: string) => void;
  onCloseOthers: (tabId: string) => void;
  onCloseAll: () => void;
  onRename: (tabId: string) => void;
  onCopyInfo: (tabId: string) => void;
  children: React.ReactNode;
}

const TabContextMenu: React.FC<TabContextMenuProps> = ({
  tabId,
  onClose,
  onCloseOthers,
  onCloseAll,
  onRename,
  onCopyInfo,
  children
}) => {
  const menu = (
    <Menu>
      <Menu.Item 
        key="rename" 
        icon={<EditOutlined />}
        onClick={() => onRename(tabId)}
      >
        重命名
      </Menu.Item>
      <Menu.Item 
        key="copy" 
        icon={<CopyOutlined />}
        onClick={() => onCopyInfo(tabId)}
      >
        复制连接信息
      </Menu.Item>
      <Menu.Divider />
      <Menu.Item 
        key="close" 
        icon={<CloseOutlined />}
        onClick={() => onClose(tabId)}
      >
        关闭
      </Menu.Item>
      <Menu.Item 
        key="closeOthers" 
        icon={<MinusCircleOutlined />}
        onClick={() => onCloseOthers(tabId)}
      >
        关闭其他
      </Menu.Item>
      <Menu.Item 
        key="closeAll" 
        icon={<CloseCircleOutlined />}
        onClick={onCloseAll}
      >
        关闭全部
      </Menu.Item>
    </Menu>
  );

  return (
    <Dropdown overlay={menu} trigger={['contextMenu']}>
      {children}
    </Dropdown>
  );
};

export default TabContextMenu;
```

#### 验收标准
- [ ] 右键菜单正常显示和工作
- [ ] 双击重命名功能正常
- [ ] 快捷键响应正常
- [ ] 拖拽排序功能正常

### Day 9: 第二阶段集成测试

#### 任务清单
- [ ] **完整功能测试**
  - 创建多个标签页
  - 标签页切换和管理
  - 终端功能验证

- [ ] **性能测试**
  - 多标签页性能
  - 内存使用情况
  - WebSocket 连接管理

- [ ] **错误处理测试**
  - 网络断开重连
  - 异常情况处理
  - 用户反馈

#### 验收标准
- [ ] 可以同时打开5个以上标签页
- [ ] 标签页切换流畅无卡顿
- [ ] 错误处理和恢复正常
- [ ] 第二阶段演示通过

---

## 💾 第三阶段：多会话管理和优化

**时间**: 第10-13工作日 (7月30日-8月2日)  
**目标**: 完善多会话管理和会话持久化  
**可交付成果**: 稳定的多会话系统

### Day 10: 会话持久化

#### 任务清单
- [ ] **实现会话状态持久化**
  - 使用 localStorage/sessionStorage
  - 会话信息的序列化和反序列化

- [ ] **添加会话恢复功能**
  - 页面刷新后恢复标签页
  - 重新建立 WebSocket 连接

- [ ] **连接历史记录**
  - 记录连接历史
  - 快速重新连接功能

#### 具体实现代码示例
```typescript
// frontend/src/services/workspaceStorage.ts
import { TabInfo } from '../types/workspace';

const STORAGE_KEY = 'bastion_workspace_tabs';

export class WorkspaceStorage {
  // 保存标签页状态
  static saveTabs(tabs: TabInfo[], activeTabId: string) {
    const serializedTabs = tabs.map(tab => ({
      ...tab,
      // 移除不能序列化的属性
      sessionId: undefined, // 会话ID需要重新创建
      connectionStatus: 'disconnected' as const,
      createdAt: tab.createdAt.toISOString(),
      lastActivity: tab.lastActivity.toISOString()
    }));

    const workspaceData = {
      tabs: serializedTabs,
      activeTabId,
      timestamp: new Date().toISOString()
    };

    localStorage.setItem(STORAGE_KEY, JSON.stringify(workspaceData));
  }

  // 加载标签页状态
  static loadTabs(): { tabs: TabInfo[]; activeTabId: string } | null {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (!data) return null;

      const workspaceData = JSON.parse(data);
      
      // 检查数据是否过期（24小时）
      const timestamp = new Date(workspaceData.timestamp);
      const now = new Date();
      const hoursDiff = (now.getTime() - timestamp.getTime()) / (1000 * 60 * 60);
      
      if (hoursDiff > 24) {
        localStorage.removeItem(STORAGE_KEY);
        return null;
      }

      const tabs = workspaceData.tabs.map((tab: any) => ({
        ...tab,
        createdAt: new Date(tab.createdAt),
        lastActivity: new Date(tab.lastActivity)
      }));

      return {
        tabs,
        activeTabId: workspaceData.activeTabId
      };
    } catch (error) {
      console.error('Failed to load workspace tabs:', error);
      return null;
    }
  }

  // 清除存储
  static clearStorage() {
    localStorage.removeItem(STORAGE_KEY);
  }

  // 记录连接历史
  static addConnectionHistory(connectionInfo: {
    assetId: number;
    assetName: string;
    credentialId: number;
    username: string;
    connectedAt: Date;
  }) {
    const HISTORY_KEY = 'bastion_connection_history';
    const MAX_HISTORY = 50;

    try {
      const historyData = localStorage.getItem(HISTORY_KEY);
      const history = historyData ? JSON.parse(historyData) : [];

      // 添加新记录
      history.unshift({
        ...connectionInfo,
        connectedAt: connectionInfo.connectedAt.toISOString()
      });

      // 限制历史记录数量
      if (history.length > MAX_HISTORY) {
        history.splice(MAX_HISTORY);
      }

      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (error) {
      console.error('Failed to save connection history:', error);
    }
  }

  // 获取连接历史
  static getConnectionHistory(): any[] {
    try {
      const historyData = localStorage.getItem('bastion_connection_history');
      return historyData ? JSON.parse(historyData) : [];
    } catch (error) {
      console.error('Failed to load connection history:', error);
      return [];
    }
  }
}
```

#### 验收标准
- [ ] 页面刷新后标签页能够恢复
- [ ] 连接历史记录正常保存和显示
- [ ] 会话恢复功能正常工作
- [ ] 存储空间使用合理

### Day 11: WebSocket 连接池管理

#### 任务清单
- [ ] **创建 WebSocket 连接池**
  - 管理多个 WebSocket 连接
  - 连接状态监控和恢复

- [ ] **实现自动重连机制**
  - 指数退避重连策略
  - 连接健康检查

- [ ] **优化连接资源管理**
  - 连接复用和清理
  - 内存泄漏预防

#### 具体实现代码示例
```typescript
// frontend/src/services/webSocketPool.ts
import { EventEmitter } from 'events';

interface ConnectionConfig {
  sessionId: string;
  url: string;
  protocols?: string[];
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

interface ConnectionInfo {
  websocket: WebSocket;
  config: ConnectionConfig;
  reconnectAttempts: number;
  lastConnected: Date;
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
}

export class WebSocketPool extends EventEmitter {
  private connections: Map<string, ConnectionInfo> = new Map();
  private reconnectTimers: Map<string, NodeJS.Timeout> = new Map();
  private healthCheckInterval?: NodeJS.Timeout;

  constructor() {
    super();
    this.startHealthCheck();
  }

  // 创建连接
  async createConnection(config: ConnectionConfig): Promise<WebSocket> {
    const existingConnection = this.connections.get(config.sessionId);
    
    // 如果已有连接且状态良好，直接返回
    if (existingConnection && existingConnection.status === 'connected') {
      return existingConnection.websocket;
    }

    // 清理旧连接
    if (existingConnection) {
      this.closeConnection(config.sessionId);
    }

    return new Promise((resolve, reject) => {
      const websocket = new WebSocket(config.url, config.protocols);
      
      const connectionInfo: ConnectionInfo = {
        websocket,
        config,
        reconnectAttempts: 0,
        lastConnected: new Date(),
        status: 'connecting'
      };

      this.connections.set(config.sessionId, connectionInfo);

      websocket.onopen = () => {
        connectionInfo.status = 'connected';
        connectionInfo.lastConnected = new Date();
        connectionInfo.reconnectAttempts = 0;
        
        this.emit('connected', config.sessionId);
        resolve(websocket);
      };

      websocket.onclose = (event) => {
        connectionInfo.status = 'disconnected';
        this.emit('disconnected', config.sessionId, event);
        
        // 如果不是正常关闭，尝试重连
        if (event.code !== 1000 && event.code !== 1001) {
          this.scheduleReconnect(config.sessionId);
        }
      };

      websocket.onerror = (error) => {
        connectionInfo.status = 'error';
        this.emit('error', config.sessionId, error);
        reject(error);
      };

      websocket.onmessage = (event) => {
        this.emit('message', config.sessionId, event.data);
      };

      // 连接超时处理
      setTimeout(() => {
        if (connectionInfo.status === 'connecting') {
          websocket.close();
          reject(new Error('Connection timeout'));
        }
      }, 10000);
    });
  }

  // 关闭连接
  closeConnection(sessionId: string): void {
    const connection = this.connections.get(sessionId);
    if (connection) {
      // 清理重连定时器
      const timer = this.reconnectTimers.get(sessionId);
      if (timer) {
        clearTimeout(timer);
        this.reconnectTimers.delete(sessionId);
      }

      // 关闭 WebSocket
      if (connection.websocket.readyState === WebSocket.OPEN) {
        connection.websocket.close(1000, 'Normal closure');
      }

      this.connections.delete(sessionId);
      this.emit('closed', sessionId);
    }
  }

  // 发送消息
  sendMessage(sessionId: string, data: any): boolean {
    const connection = this.connections.get(sessionId);
    if (connection && connection.status === 'connected') {
      connection.websocket.send(JSON.stringify(data));
      return true;
    }
    return false;
  }

  // 获取连接状态
  getConnectionStatus(sessionId: string): string {
    const connection = this.connections.get(sessionId);
    return connection ? connection.status : 'disconnected';
  }

  // 调度重连
  private scheduleReconnect(sessionId: string): void {
    const connection = this.connections.get(sessionId);
    if (!connection) return;

    const maxAttempts = connection.config.maxReconnectAttempts || 5;
    if (connection.reconnectAttempts >= maxAttempts) {
      this.emit('reconnectFailed', sessionId);
      return;
    }

    const delay = Math.min(1000 * Math.pow(2, connection.reconnectAttempts), 30000);
    connection.reconnectAttempts++;

    const timer = setTimeout(() => {
      this.reconnectTimers.delete(sessionId);
      this.createConnection(connection.config)
        .catch(error => {
          console.error(`Reconnection failed for ${sessionId}:`, error);
          this.scheduleReconnect(sessionId);
        });
    }, delay);

    this.reconnectTimers.set(sessionId, timer);
    this.emit('reconnecting', sessionId, connection.reconnectAttempts, delay);
  }

  // 健康检查
  private startHealthCheck(): void {
    this.healthCheckInterval = setInterval(() => {
      this.connections.forEach((connection, sessionId) => {
        if (connection.status === 'connected') {
          // 发送 ping 消息检查连接健康
          try {
            connection.websocket.send(JSON.stringify({ type: 'ping' }));
          } catch (error) {
            console.error(`Health check failed for ${sessionId}:`, error);
            connection.status = 'error';
            this.scheduleReconnect(sessionId);
          }
        }
      });
    }, 30000); // 每30秒检查一次
  }

  // 清理资源
  destroy(): void {
    // 清理所有连接
    this.connections.forEach((_, sessionId) => {
      this.closeConnection(sessionId);
    });

    // 清理定时器
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }

    this.reconnectTimers.forEach(timer => clearTimeout(timer));
    this.reconnectTimers.clear();
  }
}

// 全局实例
export const webSocketPool = new WebSocketPool();
```

#### 验收标准
- [ ] WebSocket 连接池正常工作
- [ ] 自动重连机制正常
- [ ] 健康检查功能正常
- [ ] 连接资源正确清理

### Day 12: 性能优化

#### 任务清单
- [ ] **内存优化**
  - 终端缓冲区管理
  - 组件卸载时清理

- [ ] **渲染性能优化**
  - 虚拟化长列表
  - 懒加载非活跃标签页

- [ ] **网络优化**
  - 消息批处理
  - 连接复用

#### 验收标准
- [ ] 内存使用合理
- [ ] 渲染性能良好
- [ ] 网络请求优化
- [ ] 长时间运行稳定

### Day 13: 第三阶段集成测试

#### 任务清单
- [ ] **稳定性测试**
  - 长时间运行测试
  - 高并发连接测试

- [ ] **恢复功能测试**
  - 页面刷新恢复
  - 网络断开恢复

- [ ] **性能基准测试**
  - 响应时间测试
  - 资源使用测试

#### 验收标准
- [ ] 稳定性测试通过
- [ ] 恢复功能正常
- [ ] 性能指标达标
- [ ] 第三阶段演示通过

---

## 🎨 第四阶段：功能完善和发布准备

**时间**: 第14-18工作日 (8月5日-8月8日)  
**目标**: 完善用户体验和发布准备  
**可交付成果**: 可发布的完整功能

### Day 14: 用户体验优化

#### 任务清单
- [ ] **快捷键系统**
  - 实现完整的快捷键支持
  - 快捷键提示和帮助

- [ ] **拖拽功能**
  - 标签页拖拽排序
  - 面板大小调整

- [ ] **主题和样式**
  - 深色主题支持
  - 自定义样式选项

### Day 15: 错误处理和用户反馈

#### 任务清单
- [ ] **完善错误处理**
  - 全局错误边界
  - 用户友好的错误提示

- [ ] **用户反馈系统**
  - 操作确认对话框
  - 进度指示器

- [ ] **帮助和文档**
  - 内置帮助系统
  - 操作指南

### Day 16: 测试和调试

#### 任务清单
- [ ] **单元测试**
  - 组件单元测试
  - 工具函数测试

- [ ] **集成测试**
  - 端到端测试
  - 用户场景测试

- [ ] **性能测试**
  - 压力测试
  - 内存泄漏检查

### Day 17: 文档和部署

#### 任务清单
- [ ] **用户文档**
  - 使用指南
  - 快捷键说明

- [ ] **开发文档**
  - API 文档
  - 维护指南

- [ ] **部署准备**
  - 构建优化
  - 环境配置

### Day 18: 发布和总结

#### 任务清单
- [ ] **发布准备**
  - 版本发布
  - 部署验证

- [ ] **项目总结**
  - 功能验收
  - 文档整理

- [ ] **后续规划**
  - 功能规划
  - 改进建议

---

## 📊 项目管理和质量保证

### 🎯 每日工作流程

1. **晨会 (9:00-9:30)**
   - 昨日完成情况回顾
   - 今日任务分配
   - 阻塞问题讨论

2. **开发时间 (9:30-17:30)**
   - 按照任务清单执行
   - 定期代码提交
   - 及时更新进度

3. **日结 (17:30-18:00)**
   - 完成情况汇报
   - 代码审查
   - 明日计划确认

### 📋 质量检查点

#### 代码质量
- [ ] ESLint 检查通过
- [ ] TypeScript 类型检查通过
- [ ] 代码覆盖率 > 80%
- [ ] 性能指标满足要求

#### 功能质量
- [ ] 所有功能点验收通过
- [ ] 用户体验流畅
- [ ] 错误处理完善
- [ ] 兼容性测试通过

### 🚨 风险管理

#### 技术风险
- **WebSocket 连接稳定性**
  - 缓解措施：完善的重连机制
  - 应急方案：降级到轮询模式

- **多标签页内存问题**
  - 缓解措施：优化内存管理
  - 应急方案：限制最大标签页数

- **组件集成复杂度**
  - 缓解措施：充分的单元测试
  - 应急方案：分阶段发布

#### 进度风险
- **任务估算偏差**
  - 缓解措施：每日进度跟踪
  - 应急方案：调整功能范围

- **依赖组件变更**
  - 缓解措施：版本锁定
  - 应急方案：快速适配

### 📈 成功指标

#### 技术指标
- [ ] 支持同时打开 10+ 个标签页
- [ ] 页面响应时间 < 200ms
- [ ] 内存使用增长 < 10MB/小时
- [ ] 连接成功率 > 95%

#### 用户体验指标
- [ ] 操作响应流畅
- [ ] 错误恢复及时
- [ ] 界面直观易用
- [ ] 功能完整可用

---

## 📞 支持和联系

### 技术支持
- 开发团队：daily standup
- 技术评审：每周三
- 问题追踪：GitHub Issues

### 项目协调
- 项目进度：每日汇报
- 需求变更：变更委员会
- 风险管理：风险评估会议

---

**文档版本**: v1.0  
**创建日期**: 2025-07-17  
**预计完成**: 2025-08-08  
**负责人**: 前端开发团队  
**审核状态**: 待审核