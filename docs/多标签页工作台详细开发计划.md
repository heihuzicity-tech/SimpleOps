# å¤šæ ‡ç­¾é¡µè¿æ¥å·¥ä½œå°è¯¦ç»†å¼€å‘è®¡åˆ’

## ğŸ“… é¡¹ç›®æ€»ä½“æ—¶é—´å®‰æ’

- **æ€»å·¥æœŸ**: 15-18 ä¸ªå·¥ä½œæ—¥
- **å¼€å§‹æ—¶é—´**: 2025-07-17
- **é¢„è®¡å®Œæˆ**: 2025-08-08
- **å¼€å‘æ¨¡å¼**: è¿­ä»£å¼å¼€å‘ï¼Œæ¯ä¸ªé˜¶æ®µå¯ç‹¬ç«‹æµ‹è¯•éªŒè¯

---

## ğŸš€ ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„æ­å»º

**æ—¶é—´**: ç¬¬1-4å·¥ä½œæ—¥ (7æœˆ17æ—¥-7æœˆ22æ—¥)  
**ç›®æ ‡**: å®ŒæˆåŸºç¡€å¸ƒå±€å’Œæ ¸å¿ƒç»„ä»¶æ¶æ„  
**å¯äº¤ä»˜æˆæœ**: å¯è¿è¡Œçš„åŸºç¡€å·¥ä½œå°é¡µé¢

### Day 1: é¡¹ç›®åˆå§‹åŒ–å’ŒåŸºç¡€å¸ƒå±€

#### ä»»åŠ¡æ¸…å•
- [ ] **åˆ›å»ºåŸºç¡€ç›®å½•ç»“æ„**
  ```bash
  mkdir -p frontend/src/components/workspace
  mkdir -p frontend/src/pages/connect
  mkdir -p frontend/src/store/workspace
  mkdir -p frontend/src/types/workspace
  ```

- [ ] **åˆ›å»ºåŸºç¡€å¸ƒå±€ç»„ä»¶**
  - æ–‡ä»¶: `frontend/src/pages/connect/WorkspaceLayout.tsx`
  - åŠŸèƒ½: å®ç°å·¦å³åˆ†æ å¸ƒå±€
  - æŠ€æœ¯: Ant Design Layout + Splitter

- [ ] **å®šä¹‰ç±»å‹æ¥å£**
  - æ–‡ä»¶: `frontend/src/types/workspace.ts`
  - å†…å®¹: TabInfo, WorkspaceState, SessionState ç­‰æ ¸å¿ƒç±»å‹

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/types/workspace.ts
export interface TabInfo {
  id: string;
  title: string;
  type: 'ssh' | 'database' | 'rdp';
  sessionId?: string;
  assetInfo: {
    id: number;
    name: string;
    address: string;
    port: number;
    protocol: string;
  };
  credentialInfo: {
    id: number;
    username: string;
    type: string;
  };
  closable: boolean;
  modified: boolean;
  connectionStatus: 'idle' | 'connecting' | 'connected' | 'disconnected' | 'error';
  createdAt: Date;
  lastActivity: Date;
}

export interface WorkspaceState {
  tabs: TabInfo[];
  activeTabId: string;
  sidebarWidth: number;
  sidebarCollapsed: boolean;
  layout: 'horizontal' | 'vertical';
}
```

#### éªŒæ”¶æ ‡å‡†
- [ ] é¡µé¢å¯ä»¥æ­£å¸¸è®¿é—® `/connect/workspace`
- [ ] å·¦å³åˆ†æ å¸ƒå±€æ­£å¸¸æ˜¾ç¤º
- [ ] å¯ä»¥æ‹–æ‹½è°ƒæ•´ä¾§è¾¹æ å®½åº¦
- [ ] å“åº”å¼å¸ƒå±€åœ¨ä¸åŒå±å¹•å°ºå¯¸ä¸‹æ­£å¸¸å·¥ä½œ

### Day 2: ä¾§è¾¹æ ç»„ä»¶é›†æˆ

#### ä»»åŠ¡æ¸…å•
- [ ] **é›†æˆResourceTreeç»„ä»¶**
  - ä¿®æ”¹ç°æœ‰ResourceTreeç»„ä»¶é€‚é…æ–°å¸ƒå±€
  - æ·»åŠ å·¥ä½œå°ä¸“ç”¨çš„äº¤äº’é€»è¾‘

- [ ] **åˆ›å»ºSidePanelç»„ä»¶**
  - æ–‡ä»¶: `frontend/src/components/workspace/SidePanel.tsx`
  - åŠŸèƒ½: é›†æˆèµ„æºæ ‘ã€æœç´¢ã€å†å²è®°å½•

- [ ] **å®ç°åŸºç¡€äº¤äº’**
  - èµ„æºæ ‘é€‰æ‹©äº‹ä»¶å¤„ç†
  - æœç´¢åŠŸèƒ½é›†æˆ
  - æŠ˜å /å±•å¼€åŠŸèƒ½

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/components/workspace/SidePanel.tsx
import React, { useState } from 'react';
import { Card, Tabs, Input, List, Button } from 'antd';
import { SearchOutlined, HistoryOutlined, FolderOutlined } from '@ant-design/icons';
import ResourceTree from '../sessions/ResourceTree';

const { TabPane } = Tabs;
const { Search } = Input;

interface SidePanelProps {
  width: number;
  collapsed: boolean;
  onAssetSelect: (asset: any) => void;
  onToggleCollapse: () => void;
}

const SidePanel: React.FC<SidePanelProps> = ({
  width,
  collapsed,
  onAssetSelect,
  onToggleCollapse
}) => {
  const [activeTab, setActiveTab] = useState('resources');
  const [searchValue, setSearchValue] = useState('');

  return (
    <div style={{ width: collapsed ? 50 : width, transition: 'width 0.3s' }}>
      {!collapsed && (
        <Card size="small" style={{ height: '100%' }}>
          <Tabs activeKey={activeTab} onChange={setActiveTab} size="small">
            <TabPane tab={<><FolderOutlined />èµ„æº</>} key="resources">
              <Search
                placeholder="æœç´¢èµ„æº"
                value={searchValue}
                onChange={(e) => setSearchValue(e.target.value)}
                style={{ marginBottom: 8 }}
                prefix={<SearchOutlined />}
              />
              <ResourceTree
                onSelect={onAssetSelect}
                resourceType="host"
                searchValue={searchValue}
              />
            </TabPane>
            <TabPane tab={<><HistoryOutlined />å†å²</>} key="history">
              <List
                size="small"
                dataSource={[]}
                renderItem={(item) => (
                  <List.Item>
                    <Button type="link" size="small">
                      {item.name}
                    </Button>
                  </List.Item>
                )}
              />
            </TabPane>
          </Tabs>
        </Card>
      )}
    </div>
  );
};

export default SidePanel;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] ä¾§è¾¹æ å¯ä»¥æ­£å¸¸åˆ‡æ¢æ ‡ç­¾é¡µï¼ˆèµ„æº/å†å²ï¼‰
- [ ] èµ„æºæ ‘é€‰æ‹©åŠŸèƒ½æ­£å¸¸
- [ ] æœç´¢åŠŸèƒ½å¯ä»¥è¿‡æ»¤èµ„æº
- [ ] æŠ˜å /å±•å¼€åŠ¨ç”»æµç•…

### Day 3: æ ‡ç­¾é¡µå®¹å™¨ç»„ä»¶

#### ä»»åŠ¡æ¸…å•
- [ ] **åˆ›å»ºTabContainerç»„ä»¶**
  - æ–‡ä»¶: `frontend/src/components/workspace/TabContainer.tsx`
  - åŠŸèƒ½: æ ‡ç­¾é¡µçš„å®¹å™¨å’ŒåŸºç¡€ç®¡ç†

- [ ] **å®ç°æ ‡ç­¾é¡µå¤´éƒ¨**
  - æ ‡ç­¾é¡µæ ‡é¢˜æ˜¾ç¤º
  - å…³é—­æŒ‰é’®
  - è¿æ¥çŠ¶æ€æŒ‡ç¤º

- [ ] **åˆ›å»ºç©ºçŠ¶æ€é¡µé¢**
  - å½“æ²¡æœ‰æ ‡ç­¾é¡µæ—¶æ˜¾ç¤ºçš„æ¬¢è¿é¡µé¢
  - å¿«é€Ÿè¿æ¥å…¥å£

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/components/workspace/TabContainer.tsx
import React from 'react';
import { Tabs, Button, Empty, Typography } from 'antd';
import { PlusOutlined, CloseOutlined } from '@ant-design/icons';
import { TabInfo } from '../../types/workspace';

const { TabPane } = Tabs;
const { Title, Paragraph } = Typography;

interface TabContainerProps {
  tabs: TabInfo[];
  activeTabId: string;
  onTabChange: (tabId: string) => void;
  onTabClose: (tabId: string) => void;
  onNewTab: () => void;
}

const TabContainer: React.FC<TabContainerProps> = ({
  tabs,
  activeTabId,
  onTabChange,
  onTabClose,
  onNewTab
}) => {
  const renderTabTitle = (tab: TabInfo) => (
    <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
      <StatusIndicator status={tab.connectionStatus} />
      <span>{tab.title}</span>
      {tab.closable && (
        <Button
          type="text"
          size="small"
          icon={<CloseOutlined />}
          onClick={(e) => {
            e.stopPropagation();
            onTabClose(tab.id);
          }}
          style={{ marginLeft: 4 }}
        />
      )}
    </div>
  );

  const renderEmptyState = () => (
    <div style={{ 
      height: '100%', 
      display: 'flex', 
      alignItems: 'center', 
      justifyContent: 'center' 
    }}>
      <Empty
        description={
          <div>
            <Title level={4}>æ¬¢è¿ä½¿ç”¨è¿æ¥å·¥ä½œå°</Title>
            <Paragraph>
              ä»å·¦ä¾§é€‰æ‹©ä¸»æœºèµ„æºå¼€å§‹è¿æ¥ï¼Œæˆ–è€…ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®åˆ›å»ºæ–°çš„è¿æ¥
            </Paragraph>
            <Button type="primary" icon={<PlusOutlined />} onClick={onNewTab}>
              æ–°å»ºè¿æ¥
            </Button>
          </div>
        }
      />
    </div>
  );

  if (tabs.length === 0) {
    return renderEmptyState();
  }

  return (
    <Tabs
      type="editable-card"
      activeKey={activeTabId}
      onChange={onTabChange}
      onEdit={(targetKey, action) => {
        if (action === 'remove') {
          onTabClose(targetKey as string);
        }
      }}
      hideAdd
      style={{ height: '100%' }}
    >
      {tabs.map(tab => (
        <TabPane
          key={tab.id}
          tab={renderTabTitle(tab)}
          closable={tab.closable}
        >
          <div style={{ height: 'calc(100vh - 120px)' }}>
            {/* è¿™é‡Œåç»­ä¼šæ”¾ç½® WebTerminal ç»„ä»¶ */}
            <div>ç»ˆç«¯å†…å®¹åŒºåŸŸ - {tab.title}</div>
          </div>
        </TabPane>
      ))}
    </Tabs>
  );
};

// è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨
const StatusIndicator: React.FC<{ status: TabInfo['connectionStatus'] }> = ({ status }) => {
  const getStatusColor = () => {
    switch (status) {
      case 'connected': return '#52c41a';
      case 'connecting': return '#1890ff';
      case 'disconnected': return '#d9d9d9';
      case 'error': return '#ff4d4f';
      default: return '#d9d9d9';
    }
  };

  return (
    <div
      style={{
        width: 8,
        height: 8,
        borderRadius: '50%',
        backgroundColor: getStatusColor(),
        display: 'inline-block'
      }}
    />
  );
};

export default TabContainer;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] ç©ºçŠ¶æ€é¡µé¢æ­£å¸¸æ˜¾ç¤º
- [ ] æ ‡ç­¾é¡µå¤´éƒ¨æ ·å¼æ­£ç¡®
- [ ] è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨é¢œè‰²æ­£ç¡®
- [ ] æ ‡ç­¾é¡µåˆ‡æ¢åŠŸèƒ½æ­£å¸¸

### Day 4: è·¯ç”±é…ç½®å’ŒåŸºç¡€é›†æˆ

#### ä»»åŠ¡æ¸…å•
- [ ] **é…ç½®æ–°è·¯ç”±**
  - æ›´æ–° `App.tsx` æ·»åŠ å·¥ä½œå°è·¯ç”±
  - æ·»åŠ æƒé™æ§åˆ¶

- [ ] **é›†æˆç°æœ‰ç»„ä»¶**
  - å°†æ–°é¡µé¢é›†æˆåˆ°ç°æœ‰åº”ç”¨ä¸­
  - ç¡®ä¿æ ·å¼ä¸€è‡´æ€§

- [ ] **åŸºç¡€åŠŸèƒ½æµ‹è¯•**
  - é¡µé¢åŠ è½½æµ‹è¯•
  - å¸ƒå±€å“åº”æµ‹è¯•
  - åŸºç¡€äº¤äº’æµ‹è¯•

#### è·¯ç”±é…ç½®ç¤ºä¾‹
```typescript
// frontend/src/App.tsx (æ›´æ–°éƒ¨åˆ†)
import WorkspaceLayout from './pages/connect/WorkspaceLayout';

// åœ¨è·¯ç”±é…ç½®ä¸­æ·»åŠ 
<Route 
  path="/connect/workspace" 
  element={
    <PermissionGuard requiredRole={['admin', 'operator', 'user']}>
      <WorkspaceLayout />
    </PermissionGuard>
  } 
/>
```

#### éªŒæ”¶æ ‡å‡†
- [ ] æ–°è·¯ç”±å¯ä»¥æ­£å¸¸è®¿é—®
- [ ] æƒé™æ§åˆ¶æ­£å¸¸å·¥ä½œ
- [ ] é¡µé¢æ ·å¼ä¸ç°æœ‰åº”ç”¨ä¸€è‡´
- [ ] ç¬¬ä¸€é˜¶æ®µåŠŸèƒ½æ¼”ç¤ºå¯ä»¥é€šè¿‡

---

## ğŸ”§ ç¬¬äºŒé˜¶æ®µï¼šæ ‡ç­¾é¡µç³»ç»Ÿå®ç°

**æ—¶é—´**: ç¬¬5-9å·¥ä½œæ—¥ (7æœˆ23æ—¥-7æœˆ29æ—¥)  
**ç›®æ ‡**: å®Œæˆæ ‡ç­¾é¡µçš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸç®¡ç†  
**å¯äº¤ä»˜æˆæœ**: å¯ä»¥åˆ›å»ºã€ç®¡ç†å’Œåˆ‡æ¢æ ‡ç­¾é¡µ

### Day 5: çŠ¶æ€ç®¡ç†å®ç°

#### ä»»åŠ¡æ¸…å•
- [ ] **åˆ›å»º workspaceSlice**
  - æ–‡ä»¶: `frontend/src/store/workspaceSlice.ts`
  - åŠŸèƒ½: æ ‡ç­¾é¡µçŠ¶æ€ç®¡ç†

- [ ] **å®šä¹‰ Actions å’Œ Reducers**
  - æ ‡ç­¾é¡µå¢åˆ æ”¹æŸ¥
  - çŠ¶æ€æ›´æ–°é€»è¾‘

- [ ] **é›†æˆåˆ°å…¨å±€ store**
  - æ›´æ–° `store/index.ts`
  - ç±»å‹å®šä¹‰æ›´æ–°

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/store/workspaceSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { TabInfo, WorkspaceState } from '../types/workspace';
import { nanoid } from 'nanoid';

const initialState: WorkspaceState = {
  tabs: [],
  activeTabId: '',
  sidebarWidth: 280,
  sidebarCollapsed: false,
  layout: 'horizontal'
};

// å¼‚æ­¥åˆ›å»ºæ–°æ ‡ç­¾é¡µ
export const createNewTab = createAsyncThunk(
  'workspace/createNewTab',
  async (params: { assetInfo: any; credentialInfo: any }) => {
    const { assetInfo, credentialInfo } = params;
    
    const tabId = nanoid();
    const tab: TabInfo = {
      id: tabId,
      title: `${assetInfo.name} (${credentialInfo.username})`,
      type: 'ssh',
      assetInfo,
      credentialInfo,
      closable: true,
      modified: false,
      connectionStatus: 'idle',
      createdAt: new Date(),
      lastActivity: new Date()
    };
    
    return tab;
  }
);

// åˆ›å»ºä¼šè¯è¿æ¥
export const connectTab = createAsyncThunk(
  'workspace/connectTab',
  async (params: { tabId: string; connectionParams: any }) => {
    const { tabId, connectionParams } = params;
    
    // è°ƒç”¨ç°æœ‰çš„ SSH è¿æ¥ API
    const response = await sshAPI.createSession(connectionParams);
    
    return {
      tabId,
      sessionId: response.id,
      connectionStatus: 'connected' as const
    };
  }
);

const workspaceSlice = createSlice({
  name: 'workspace',
  initialState,
  reducers: {
    // æ·»åŠ æ ‡ç­¾é¡µ
    addTab: (state, action: PayloadAction<TabInfo>) => {
      state.tabs.push(action.payload);
      state.activeTabId = action.payload.id;
    },
    
    // å…³é—­æ ‡ç­¾é¡µ
    closeTab: (state, action: PayloadAction<string>) => {
      const tabIndex = state.tabs.findIndex(tab => tab.id === action.payload);
      if (tabIndex !== -1) {
        state.tabs.splice(tabIndex, 1);
        
        // å¦‚æœå…³é—­çš„æ˜¯å½“å‰æ´»è·ƒæ ‡ç­¾é¡µï¼Œåˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾é¡µ
        if (state.activeTabId === action.payload) {
          if (state.tabs.length > 0) {
            const newActiveIndex = Math.max(0, tabIndex - 1);
            state.activeTabId = state.tabs[newActiveIndex]?.id || '';
          } else {
            state.activeTabId = '';
          }
        }
      }
    },
    
    // åˆ‡æ¢æ´»è·ƒæ ‡ç­¾é¡µ
    setActiveTab: (state, action: PayloadAction<string>) => {
      state.activeTabId = action.payload;
    },
    
    // æ›´æ–°æ ‡ç­¾é¡µçŠ¶æ€
    updateTabStatus: (state, action: PayloadAction<{ tabId: string; status: TabInfo['connectionStatus'] }>) => {
      const tab = state.tabs.find(t => t.id === action.payload.tabId);
      if (tab) {
        tab.connectionStatus = action.payload.status;
        tab.lastActivity = new Date();
      }
    },
    
    // æ›´æ–°æ ‡ç­¾é¡µæ ‡é¢˜
    updateTabTitle: (state, action: PayloadAction<{ tabId: string; title: string }>) => {
      const tab = state.tabs.find(t => t.id === action.payload.tabId);
      if (tab) {
        tab.title = action.payload.title;
        tab.modified = true;
      }
    },
    
    // è®¾ç½®ä¾§è¾¹æ å®½åº¦
    setSidebarWidth: (state, action: PayloadAction<number>) => {
      state.sidebarWidth = action.payload;
    },
    
    // åˆ‡æ¢ä¾§è¾¹æ æŠ˜å çŠ¶æ€
    toggleSidebarCollapsed: (state) => {
      state.sidebarCollapsed = !state.sidebarCollapsed;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(createNewTab.fulfilled, (state, action) => {
        state.tabs.push(action.payload);
        state.activeTabId = action.payload.id;
      })
      .addCase(connectTab.pending, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.meta.arg.tabId);
        if (tab) {
          tab.connectionStatus = 'connecting';
        }
      })
      .addCase(connectTab.fulfilled, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.payload.tabId);
        if (tab) {
          tab.sessionId = action.payload.sessionId;
          tab.connectionStatus = action.payload.connectionStatus;
        }
      })
      .addCase(connectTab.rejected, (state, action) => {
        const tab = state.tabs.find(t => t.id === action.meta.arg.tabId);
        if (tab) {
          tab.connectionStatus = 'error';
        }
      });
  }
});

export const {
  addTab,
  closeTab,
  setActiveTab,
  updateTabStatus,
  updateTabTitle,
  setSidebarWidth,
  toggleSidebarCollapsed
} = workspaceSlice.actions;

export default workspaceSlice.reducer;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] çŠ¶æ€ç®¡ç†æ­£å¸¸å·¥ä½œ
- [ ] æ ‡ç­¾é¡µå¢åˆ æ”¹æŸ¥åŠŸèƒ½æ­£å¸¸
- [ ] Redux DevTools å¯ä»¥æŸ¥çœ‹çŠ¶æ€å˜åŒ–
- [ ] ç±»å‹æ£€æŸ¥é€šè¿‡

### Day 6: å‡­è¯é€‰æ‹©å’Œè¿æ¥åˆ›å»º

#### ä»»åŠ¡æ¸…å•
- [ ] **å®ç°è¿æ¥åˆ›å»ºæµç¨‹**
  - ä»èµ„æºæ ‘é€‰æ‹©ä¸»æœº
  - å¼¹å‡ºå‡­è¯é€‰æ‹©å¯¹è¯æ¡†
  - åˆ›å»ºæ–°æ ‡ç­¾é¡µ

- [ ] **é›†æˆCredentialSelectorç»„ä»¶**
  - å¤ç”¨ç°æœ‰çš„å‡­è¯é€‰æ‹©ç»„ä»¶
  - é€‚é…å·¥ä½œå°åœºæ™¯

- [ ] **è¿æ¥çŠ¶æ€ç®¡ç†**
  - è¿æ¥è¿‡ç¨‹çŠ¶æ€æ˜¾ç¤º
  - é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/components/workspace/ConnectionCreator.tsx
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { Modal, message } from 'antd';
import CredentialSelector from '../sessions/CredentialSelector';
import { createNewTab, connectTab } from '../../store/workspaceSlice';
import { performConnectionTest } from '../../services/connectionTest';

interface ConnectionCreatorProps {
  visible: boolean;
  selectedAsset: any;
  credentials: any[];
  onClose: () => void;
}

const ConnectionCreator: React.FC<ConnectionCreatorProps> = ({
  visible,
  selectedAsset,
  credentials,
  onClose
}) => {
  const dispatch = useDispatch();
  const [connecting, setConnecting] = useState(false);

  const handleCredentialSelect = async (credentialId: number) => {
    if (!selectedAsset) return;
    
    setConnecting(true);
    
    try {
      // å…ˆè¿›è¡Œè¿æ¥æµ‹è¯•
      const testResult = await performConnectionTest(dispatch, selectedAsset, credentialId);
      
      if (!testResult.success) {
        setConnecting(false);
        return;
      }
      
      // åˆ›å»ºæ–°æ ‡ç­¾é¡µ
      const credential = credentials.find(c => c.id === credentialId);
      const newTabAction = await dispatch(createNewTab({
        assetInfo: selectedAsset,
        credentialInfo: credential
      }));
      
      if (createNewTab.fulfilled.match(newTabAction)) {
        const tab = newTabAction.payload;
        
        // åˆ›å»ºè¿æ¥
        await dispatch(connectTab({
          tabId: tab.id,
          connectionParams: {
            asset_id: selectedAsset.id,
            credential_id: credentialId,
            protocol: selectedAsset.protocol || 'ssh',
            width: 80,
            height: 24
          }
        }));
        
        message.success(`æˆåŠŸè¿æ¥åˆ° ${selectedAsset.name}`);
        onClose();
      }
    } catch (error: any) {
      message.error(`è¿æ¥å¤±è´¥: ${error.message}`);
    } finally {
      setConnecting(false);
    }
  };

  return (
    <CredentialSelector
      visible={visible}
      onCancel={onClose}
      onSelect={handleCredentialSelect}
      asset={selectedAsset}
      credentials={credentials}
      loading={connecting}
    />
  );
};

export default ConnectionCreator;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] ä»èµ„æºæ ‘é€‰æ‹©ä¸»æœºåå¼¹å‡ºå‡­è¯é€‰æ‹©
- [ ] é€‰æ‹©å‡­è¯åèƒ½æˆåŠŸåˆ›å»ºæ ‡ç­¾é¡µ
- [ ] è¿æ¥æµ‹è¯•åŠŸèƒ½æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆæ­£å¸¸

### Day 7: WebTerminal ç»„ä»¶é›†æˆ

#### ä»»åŠ¡æ¸…å•
- [ ] **ä¿®æ”¹ WebTerminal ç»„ä»¶**
  - é€‚é…å·¥ä½œå°ç¯å¢ƒ
  - æ”¯æŒå¤šå®ä¾‹åŒæ—¶è¿è¡Œ

- [ ] **åˆ›å»º ConnectionPanel ç»„ä»¶**
  - å°è£… WebTerminal
  - æ·»åŠ è¿æ¥ç®¡ç†åŠŸèƒ½

- [ ] **å®ç°ç»ˆç«¯ç”Ÿå‘½å‘¨æœŸç®¡ç†**
  - åˆ›å»ºã€æ¿€æ´»ã€é”€æ¯
  - èµ„æºæ¸…ç†

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/components/workspace/ConnectionPanel.tsx
import React, { useEffect, useRef } from 'react';
import { useDispatch } from 'react-redux';
import { message } from 'antd';
import WebTerminal from '../ssh/WebTerminal';
import { updateTabStatus } from '../../store/workspaceSlice';
import { TabInfo } from '../../types/workspace';

interface ConnectionPanelProps {
  tab: TabInfo;
  isActive: boolean;
  onClose: () => void;
}

const ConnectionPanel: React.FC<ConnectionPanelProps> = ({
  tab,
  isActive,
  onClose
}) => {
  const dispatch = useDispatch();
  const terminalRef = useRef<any>(null);

  // å¤„ç†è¿æ¥çŠ¶æ€å˜åŒ–
  const handleConnectionStatusChange = (status: 'connected' | 'connecting' | 'disconnected' | 'error') => {
    dispatch(updateTabStatus({ tabId: tab.id, status }));
  };

  // å¤„ç†ç»ˆç«¯é”™è¯¯
  const handleError = (error: Error) => {
    console.error(`Terminal error for tab ${tab.id}:`, error);
    dispatch(updateTabStatus({ tabId: tab.id, status: 'error' }));
    message.error(`è¿æ¥é”™è¯¯: ${error.message}`);
  };

  // å¤„ç†ç»ˆç«¯å…³é—­
  const handleClose = () => {
    onClose();
  };

  // å½“æ ‡ç­¾é¡µæ¿€æ´»æ—¶ï¼Œè°ƒæ•´ç»ˆç«¯å¤§å°
  useEffect(() => {
    if (isActive && terminalRef.current) {
      // å»¶è¿Ÿè°ƒæ•´å¤§å°ï¼Œç¡®ä¿DOMå·²æ›´æ–°
      setTimeout(() => {
        terminalRef.current?.fit();
      }, 100);
    }
  }, [isActive]);

  // å¦‚æœæ²¡æœ‰ä¼šè¯IDï¼Œæ˜¾ç¤ºè¿æ¥ä¸­çŠ¶æ€
  if (!tab.sessionId) {
    return (
      <div style={{ 
        height: '100%', 
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center' 
      }}>
        <div>æ­£åœ¨å»ºç«‹è¿æ¥...</div>
      </div>
    );
  }

  return (
    <div style={{ height: '100%', position: 'relative' }}>
      <WebTerminal
        ref={terminalRef}
        sessionId={tab.sessionId}
        onClose={handleClose}
        onError={handleError}
        onStatusChange={handleConnectionStatusChange}
        // åªæœ‰æ´»è·ƒæ ‡ç­¾é¡µæ‰å¯ç”¨ç»ˆç«¯
        disabled={!isActive}
      />
    </div>
  );
};

export default ConnectionPanel;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] WebTerminal åœ¨æ ‡ç­¾é¡µä¸­æ­£å¸¸å·¥ä½œ
- [ ] å¤šä¸ªç»ˆç«¯å¯ä»¥åŒæ—¶å­˜åœ¨
- [ ] åˆ‡æ¢æ ‡ç­¾é¡µæ—¶ç»ˆç«¯æ­£å¸¸æ˜¾ç¤º
- [ ] ç»ˆç«¯å¤§å°è‡ªåŠ¨è°ƒæ•´

### Day 8: æ ‡ç­¾é¡µæ“ä½œåŠŸèƒ½

#### ä»»åŠ¡æ¸…å•
- [ ] **å®ç°æ ‡ç­¾é¡µå³é”®èœå•**
  - å…³é—­ã€å…³é—­å…¶ä»–ã€å…³é—­å…¨éƒ¨
  - é‡å‘½åæ ‡ç­¾é¡µ
  - å¤åˆ¶è¿æ¥ä¿¡æ¯

- [ ] **æ·»åŠ æ ‡ç­¾é¡µå¿«æ·æ“ä½œ**
  - åŒå‡»é‡å‘½å
  - ä¸­é”®å…³é—­
  - é”®ç›˜å¿«æ·é”®

- [ ] **å®ç°æ ‡ç­¾é¡µæ‹–æ‹½æ’åº**
  - ä½¿ç”¨ react-sortable-hoc æˆ–ç±»ä¼¼åº“
  - æ‹–æ‹½è§†è§‰åé¦ˆ

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/components/workspace/TabContextMenu.tsx
import React from 'react';
import { Menu, Dropdown } from 'antd';
import { 
  CloseOutlined, 
  EditOutlined, 
  CopyOutlined,
  CloseCircleOutlined,
  MinusCircleOutlined 
} from '@ant-design/icons';

interface TabContextMenuProps {
  tabId: string;
  onClose: (tabId: string) => void;
  onCloseOthers: (tabId: string) => void;
  onCloseAll: () => void;
  onRename: (tabId: string) => void;
  onCopyInfo: (tabId: string) => void;
  children: React.ReactNode;
}

const TabContextMenu: React.FC<TabContextMenuProps> = ({
  tabId,
  onClose,
  onCloseOthers,
  onCloseAll,
  onRename,
  onCopyInfo,
  children
}) => {
  const menu = (
    <Menu>
      <Menu.Item 
        key="rename" 
        icon={<EditOutlined />}
        onClick={() => onRename(tabId)}
      >
        é‡å‘½å
      </Menu.Item>
      <Menu.Item 
        key="copy" 
        icon={<CopyOutlined />}
        onClick={() => onCopyInfo(tabId)}
      >
        å¤åˆ¶è¿æ¥ä¿¡æ¯
      </Menu.Item>
      <Menu.Divider />
      <Menu.Item 
        key="close" 
        icon={<CloseOutlined />}
        onClick={() => onClose(tabId)}
      >
        å…³é—­
      </Menu.Item>
      <Menu.Item 
        key="closeOthers" 
        icon={<MinusCircleOutlined />}
        onClick={() => onCloseOthers(tabId)}
      >
        å…³é—­å…¶ä»–
      </Menu.Item>
      <Menu.Item 
        key="closeAll" 
        icon={<CloseCircleOutlined />}
        onClick={onCloseAll}
      >
        å…³é—­å…¨éƒ¨
      </Menu.Item>
    </Menu>
  );

  return (
    <Dropdown overlay={menu} trigger={['contextMenu']}>
      {children}
    </Dropdown>
  );
};

export default TabContextMenu;
```

#### éªŒæ”¶æ ‡å‡†
- [ ] å³é”®èœå•æ­£å¸¸æ˜¾ç¤ºå’Œå·¥ä½œ
- [ ] åŒå‡»é‡å‘½ååŠŸèƒ½æ­£å¸¸
- [ ] å¿«æ·é”®å“åº”æ­£å¸¸
- [ ] æ‹–æ‹½æ’åºåŠŸèƒ½æ­£å¸¸

### Day 9: ç¬¬äºŒé˜¶æ®µé›†æˆæµ‹è¯•

#### ä»»åŠ¡æ¸…å•
- [ ] **å®Œæ•´åŠŸèƒ½æµ‹è¯•**
  - åˆ›å»ºå¤šä¸ªæ ‡ç­¾é¡µ
  - æ ‡ç­¾é¡µåˆ‡æ¢å’Œç®¡ç†
  - ç»ˆç«¯åŠŸèƒ½éªŒè¯

- [ ] **æ€§èƒ½æµ‹è¯•**
  - å¤šæ ‡ç­¾é¡µæ€§èƒ½
  - å†…å­˜ä½¿ç”¨æƒ…å†µ
  - WebSocket è¿æ¥ç®¡ç†

- [ ] **é”™è¯¯å¤„ç†æµ‹è¯•**
  - ç½‘ç»œæ–­å¼€é‡è¿
  - å¼‚å¸¸æƒ…å†µå¤„ç†
  - ç”¨æˆ·åé¦ˆ

#### éªŒæ”¶æ ‡å‡†
- [ ] å¯ä»¥åŒæ—¶æ‰“å¼€5ä¸ªä»¥ä¸Šæ ‡ç­¾é¡µ
- [ ] æ ‡ç­¾é¡µåˆ‡æ¢æµç•…æ— å¡é¡¿
- [ ] é”™è¯¯å¤„ç†å’Œæ¢å¤æ­£å¸¸
- [ ] ç¬¬äºŒé˜¶æ®µæ¼”ç¤ºé€šè¿‡

---

## ğŸ’¾ ç¬¬ä¸‰é˜¶æ®µï¼šå¤šä¼šè¯ç®¡ç†å’Œä¼˜åŒ–

**æ—¶é—´**: ç¬¬10-13å·¥ä½œæ—¥ (7æœˆ30æ—¥-8æœˆ2æ—¥)  
**ç›®æ ‡**: å®Œå–„å¤šä¼šè¯ç®¡ç†å’Œä¼šè¯æŒä¹…åŒ–  
**å¯äº¤ä»˜æˆæœ**: ç¨³å®šçš„å¤šä¼šè¯ç³»ç»Ÿ

### Day 10: ä¼šè¯æŒä¹…åŒ–

#### ä»»åŠ¡æ¸…å•
- [ ] **å®ç°ä¼šè¯çŠ¶æ€æŒä¹…åŒ–**
  - ä½¿ç”¨ localStorage/sessionStorage
  - ä¼šè¯ä¿¡æ¯çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–

- [ ] **æ·»åŠ ä¼šè¯æ¢å¤åŠŸèƒ½**
  - é¡µé¢åˆ·æ–°åæ¢å¤æ ‡ç­¾é¡µ
  - é‡æ–°å»ºç«‹ WebSocket è¿æ¥

- [ ] **è¿æ¥å†å²è®°å½•**
  - è®°å½•è¿æ¥å†å²
  - å¿«é€Ÿé‡æ–°è¿æ¥åŠŸèƒ½

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/services/workspaceStorage.ts
import { TabInfo } from '../types/workspace';

const STORAGE_KEY = 'bastion_workspace_tabs';

export class WorkspaceStorage {
  // ä¿å­˜æ ‡ç­¾é¡µçŠ¶æ€
  static saveTabs(tabs: TabInfo[], activeTabId: string) {
    const serializedTabs = tabs.map(tab => ({
      ...tab,
      // ç§»é™¤ä¸èƒ½åºåˆ—åŒ–çš„å±æ€§
      sessionId: undefined, // ä¼šè¯IDéœ€è¦é‡æ–°åˆ›å»º
      connectionStatus: 'disconnected' as const,
      createdAt: tab.createdAt.toISOString(),
      lastActivity: tab.lastActivity.toISOString()
    }));

    const workspaceData = {
      tabs: serializedTabs,
      activeTabId,
      timestamp: new Date().toISOString()
    };

    localStorage.setItem(STORAGE_KEY, JSON.stringify(workspaceData));
  }

  // åŠ è½½æ ‡ç­¾é¡µçŠ¶æ€
  static loadTabs(): { tabs: TabInfo[]; activeTabId: string } | null {
    try {
      const data = localStorage.getItem(STORAGE_KEY);
      if (!data) return null;

      const workspaceData = JSON.parse(data);
      
      // æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸï¼ˆ24å°æ—¶ï¼‰
      const timestamp = new Date(workspaceData.timestamp);
      const now = new Date();
      const hoursDiff = (now.getTime() - timestamp.getTime()) / (1000 * 60 * 60);
      
      if (hoursDiff > 24) {
        localStorage.removeItem(STORAGE_KEY);
        return null;
      }

      const tabs = workspaceData.tabs.map((tab: any) => ({
        ...tab,
        createdAt: new Date(tab.createdAt),
        lastActivity: new Date(tab.lastActivity)
      }));

      return {
        tabs,
        activeTabId: workspaceData.activeTabId
      };
    } catch (error) {
      console.error('Failed to load workspace tabs:', error);
      return null;
    }
  }

  // æ¸…é™¤å­˜å‚¨
  static clearStorage() {
    localStorage.removeItem(STORAGE_KEY);
  }

  // è®°å½•è¿æ¥å†å²
  static addConnectionHistory(connectionInfo: {
    assetId: number;
    assetName: string;
    credentialId: number;
    username: string;
    connectedAt: Date;
  }) {
    const HISTORY_KEY = 'bastion_connection_history';
    const MAX_HISTORY = 50;

    try {
      const historyData = localStorage.getItem(HISTORY_KEY);
      const history = historyData ? JSON.parse(historyData) : [];

      // æ·»åŠ æ–°è®°å½•
      history.unshift({
        ...connectionInfo,
        connectedAt: connectionInfo.connectedAt.toISOString()
      });

      // é™åˆ¶å†å²è®°å½•æ•°é‡
      if (history.length > MAX_HISTORY) {
        history.splice(MAX_HISTORY);
      }

      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    } catch (error) {
      console.error('Failed to save connection history:', error);
    }
  }

  // è·å–è¿æ¥å†å²
  static getConnectionHistory(): any[] {
    try {
      const historyData = localStorage.getItem('bastion_connection_history');
      return historyData ? JSON.parse(historyData) : [];
    } catch (error) {
      console.error('Failed to load connection history:', error);
      return [];
    }
  }
}
```

#### éªŒæ”¶æ ‡å‡†
- [ ] é¡µé¢åˆ·æ–°åæ ‡ç­¾é¡µèƒ½å¤Ÿæ¢å¤
- [ ] è¿æ¥å†å²è®°å½•æ­£å¸¸ä¿å­˜å’Œæ˜¾ç¤º
- [ ] ä¼šè¯æ¢å¤åŠŸèƒ½æ­£å¸¸å·¥ä½œ
- [ ] å­˜å‚¨ç©ºé—´ä½¿ç”¨åˆç†

### Day 11: WebSocket è¿æ¥æ± ç®¡ç†

#### ä»»åŠ¡æ¸…å•
- [ ] **åˆ›å»º WebSocket è¿æ¥æ± **
  - ç®¡ç†å¤šä¸ª WebSocket è¿æ¥
  - è¿æ¥çŠ¶æ€ç›‘æ§å’Œæ¢å¤

- [ ] **å®ç°è‡ªåŠ¨é‡è¿æœºåˆ¶**
  - æŒ‡æ•°é€€é¿é‡è¿ç­–ç•¥
  - è¿æ¥å¥åº·æ£€æŸ¥

- [ ] **ä¼˜åŒ–è¿æ¥èµ„æºç®¡ç†**
  - è¿æ¥å¤ç”¨å’Œæ¸…ç†
  - å†…å­˜æ³„æ¼é¢„é˜²

#### å…·ä½“å®ç°ä»£ç ç¤ºä¾‹
```typescript
// frontend/src/services/webSocketPool.ts
import { EventEmitter } from 'events';

interface ConnectionConfig {
  sessionId: string;
  url: string;
  protocols?: string[];
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
}

interface ConnectionInfo {
  websocket: WebSocket;
  config: ConnectionConfig;
  reconnectAttempts: number;
  lastConnected: Date;
  status: 'connecting' | 'connected' | 'disconnected' | 'error';
}

export class WebSocketPool extends EventEmitter {
  private connections: Map<string, ConnectionInfo> = new Map();
  private reconnectTimers: Map<string, NodeJS.Timeout> = new Map();
  private healthCheckInterval?: NodeJS.Timeout;

  constructor() {
    super();
    this.startHealthCheck();
  }

  // åˆ›å»ºè¿æ¥
  async createConnection(config: ConnectionConfig): Promise<WebSocket> {
    const existingConnection = this.connections.get(config.sessionId);
    
    // å¦‚æœå·²æœ‰è¿æ¥ä¸”çŠ¶æ€è‰¯å¥½ï¼Œç›´æ¥è¿”å›
    if (existingConnection && existingConnection.status === 'connected') {
      return existingConnection.websocket;
    }

    // æ¸…ç†æ—§è¿æ¥
    if (existingConnection) {
      this.closeConnection(config.sessionId);
    }

    return new Promise((resolve, reject) => {
      const websocket = new WebSocket(config.url, config.protocols);
      
      const connectionInfo: ConnectionInfo = {
        websocket,
        config,
        reconnectAttempts: 0,
        lastConnected: new Date(),
        status: 'connecting'
      };

      this.connections.set(config.sessionId, connectionInfo);

      websocket.onopen = () => {
        connectionInfo.status = 'connected';
        connectionInfo.lastConnected = new Date();
        connectionInfo.reconnectAttempts = 0;
        
        this.emit('connected', config.sessionId);
        resolve(websocket);
      };

      websocket.onclose = (event) => {
        connectionInfo.status = 'disconnected';
        this.emit('disconnected', config.sessionId, event);
        
        // å¦‚æœä¸æ˜¯æ­£å¸¸å…³é—­ï¼Œå°è¯•é‡è¿
        if (event.code !== 1000 && event.code !== 1001) {
          this.scheduleReconnect(config.sessionId);
        }
      };

      websocket.onerror = (error) => {
        connectionInfo.status = 'error';
        this.emit('error', config.sessionId, error);
        reject(error);
      };

      websocket.onmessage = (event) => {
        this.emit('message', config.sessionId, event.data);
      };

      // è¿æ¥è¶…æ—¶å¤„ç†
      setTimeout(() => {
        if (connectionInfo.status === 'connecting') {
          websocket.close();
          reject(new Error('Connection timeout'));
        }
      }, 10000);
    });
  }

  // å…³é—­è¿æ¥
  closeConnection(sessionId: string): void {
    const connection = this.connections.get(sessionId);
    if (connection) {
      // æ¸…ç†é‡è¿å®šæ—¶å™¨
      const timer = this.reconnectTimers.get(sessionId);
      if (timer) {
        clearTimeout(timer);
        this.reconnectTimers.delete(sessionId);
      }

      // å…³é—­ WebSocket
      if (connection.websocket.readyState === WebSocket.OPEN) {
        connection.websocket.close(1000, 'Normal closure');
      }

      this.connections.delete(sessionId);
      this.emit('closed', sessionId);
    }
  }

  // å‘é€æ¶ˆæ¯
  sendMessage(sessionId: string, data: any): boolean {
    const connection = this.connections.get(sessionId);
    if (connection && connection.status === 'connected') {
      connection.websocket.send(JSON.stringify(data));
      return true;
    }
    return false;
  }

  // è·å–è¿æ¥çŠ¶æ€
  getConnectionStatus(sessionId: string): string {
    const connection = this.connections.get(sessionId);
    return connection ? connection.status : 'disconnected';
  }

  // è°ƒåº¦é‡è¿
  private scheduleReconnect(sessionId: string): void {
    const connection = this.connections.get(sessionId);
    if (!connection) return;

    const maxAttempts = connection.config.maxReconnectAttempts || 5;
    if (connection.reconnectAttempts >= maxAttempts) {
      this.emit('reconnectFailed', sessionId);
      return;
    }

    const delay = Math.min(1000 * Math.pow(2, connection.reconnectAttempts), 30000);
    connection.reconnectAttempts++;

    const timer = setTimeout(() => {
      this.reconnectTimers.delete(sessionId);
      this.createConnection(connection.config)
        .catch(error => {
          console.error(`Reconnection failed for ${sessionId}:`, error);
          this.scheduleReconnect(sessionId);
        });
    }, delay);

    this.reconnectTimers.set(sessionId, timer);
    this.emit('reconnecting', sessionId, connection.reconnectAttempts, delay);
  }

  // å¥åº·æ£€æŸ¥
  private startHealthCheck(): void {
    this.healthCheckInterval = setInterval(() => {
      this.connections.forEach((connection, sessionId) => {
        if (connection.status === 'connected') {
          // å‘é€ ping æ¶ˆæ¯æ£€æŸ¥è¿æ¥å¥åº·
          try {
            connection.websocket.send(JSON.stringify({ type: 'ping' }));
          } catch (error) {
            console.error(`Health check failed for ${sessionId}:`, error);
            connection.status = 'error';
            this.scheduleReconnect(sessionId);
          }
        }
      });
    }, 30000); // æ¯30ç§’æ£€æŸ¥ä¸€æ¬¡
  }

  // æ¸…ç†èµ„æº
  destroy(): void {
    // æ¸…ç†æ‰€æœ‰è¿æ¥
    this.connections.forEach((_, sessionId) => {
      this.closeConnection(sessionId);
    });

    // æ¸…ç†å®šæ—¶å™¨
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }

    this.reconnectTimers.forEach(timer => clearTimeout(timer));
    this.reconnectTimers.clear();
  }
}

// å…¨å±€å®ä¾‹
export const webSocketPool = new WebSocketPool();
```

#### éªŒæ”¶æ ‡å‡†
- [ ] WebSocket è¿æ¥æ± æ­£å¸¸å·¥ä½œ
- [ ] è‡ªåŠ¨é‡è¿æœºåˆ¶æ­£å¸¸
- [ ] å¥åº·æ£€æŸ¥åŠŸèƒ½æ­£å¸¸
- [ ] è¿æ¥èµ„æºæ­£ç¡®æ¸…ç†

### Day 12: æ€§èƒ½ä¼˜åŒ–

#### ä»»åŠ¡æ¸…å•
- [ ] **å†…å­˜ä¼˜åŒ–**
  - ç»ˆç«¯ç¼“å†²åŒºç®¡ç†
  - ç»„ä»¶å¸è½½æ—¶æ¸…ç†

- [ ] **æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–**
  - è™šæ‹ŸåŒ–é•¿åˆ—è¡¨
  - æ‡’åŠ è½½éæ´»è·ƒæ ‡ç­¾é¡µ

- [ ] **ç½‘ç»œä¼˜åŒ–**
  - æ¶ˆæ¯æ‰¹å¤„ç†
  - è¿æ¥å¤ç”¨

#### éªŒæ”¶æ ‡å‡†
- [ ] å†…å­˜ä½¿ç”¨åˆç†
- [ ] æ¸²æŸ“æ€§èƒ½è‰¯å¥½
- [ ] ç½‘ç»œè¯·æ±‚ä¼˜åŒ–
- [ ] é•¿æ—¶é—´è¿è¡Œç¨³å®š

### Day 13: ç¬¬ä¸‰é˜¶æ®µé›†æˆæµ‹è¯•

#### ä»»åŠ¡æ¸…å•
- [ ] **ç¨³å®šæ€§æµ‹è¯•**
  - é•¿æ—¶é—´è¿è¡Œæµ‹è¯•
  - é«˜å¹¶å‘è¿æ¥æµ‹è¯•

- [ ] **æ¢å¤åŠŸèƒ½æµ‹è¯•**
  - é¡µé¢åˆ·æ–°æ¢å¤
  - ç½‘ç»œæ–­å¼€æ¢å¤

- [ ] **æ€§èƒ½åŸºå‡†æµ‹è¯•**
  - å“åº”æ—¶é—´æµ‹è¯•
  - èµ„æºä½¿ç”¨æµ‹è¯•

#### éªŒæ”¶æ ‡å‡†
- [ ] ç¨³å®šæ€§æµ‹è¯•é€šè¿‡
- [ ] æ¢å¤åŠŸèƒ½æ­£å¸¸
- [ ] æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡
- [ ] ç¬¬ä¸‰é˜¶æ®µæ¼”ç¤ºé€šè¿‡

---

## ğŸ¨ ç¬¬å››é˜¶æ®µï¼šåŠŸèƒ½å®Œå–„å’Œå‘å¸ƒå‡†å¤‡

**æ—¶é—´**: ç¬¬14-18å·¥ä½œæ—¥ (8æœˆ5æ—¥-8æœˆ8æ—¥)  
**ç›®æ ‡**: å®Œå–„ç”¨æˆ·ä½“éªŒå’Œå‘å¸ƒå‡†å¤‡  
**å¯äº¤ä»˜æˆæœ**: å¯å‘å¸ƒçš„å®Œæ•´åŠŸèƒ½

### Day 14: ç”¨æˆ·ä½“éªŒä¼˜åŒ–

#### ä»»åŠ¡æ¸…å•
- [ ] **å¿«æ·é”®ç³»ç»Ÿ**
  - å®ç°å®Œæ•´çš„å¿«æ·é”®æ”¯æŒ
  - å¿«æ·é”®æç¤ºå’Œå¸®åŠ©

- [ ] **æ‹–æ‹½åŠŸèƒ½**
  - æ ‡ç­¾é¡µæ‹–æ‹½æ’åº
  - é¢æ¿å¤§å°è°ƒæ•´

- [ ] **ä¸»é¢˜å’Œæ ·å¼**
  - æ·±è‰²ä¸»é¢˜æ”¯æŒ
  - è‡ªå®šä¹‰æ ·å¼é€‰é¡¹

### Day 15: é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ

#### ä»»åŠ¡æ¸…å•
- [ ] **å®Œå–„é”™è¯¯å¤„ç†**
  - å…¨å±€é”™è¯¯è¾¹ç•Œ
  - ç”¨æˆ·å‹å¥½çš„é”™è¯¯æç¤º

- [ ] **ç”¨æˆ·åé¦ˆç³»ç»Ÿ**
  - æ“ä½œç¡®è®¤å¯¹è¯æ¡†
  - è¿›åº¦æŒ‡ç¤ºå™¨

- [ ] **å¸®åŠ©å’Œæ–‡æ¡£**
  - å†…ç½®å¸®åŠ©ç³»ç»Ÿ
  - æ“ä½œæŒ‡å—

### Day 16: æµ‹è¯•å’Œè°ƒè¯•

#### ä»»åŠ¡æ¸…å•
- [ ] **å•å…ƒæµ‹è¯•**
  - ç»„ä»¶å•å…ƒæµ‹è¯•
  - å·¥å…·å‡½æ•°æµ‹è¯•

- [ ] **é›†æˆæµ‹è¯•**
  - ç«¯åˆ°ç«¯æµ‹è¯•
  - ç”¨æˆ·åœºæ™¯æµ‹è¯•

- [ ] **æ€§èƒ½æµ‹è¯•**
  - å‹åŠ›æµ‹è¯•
  - å†…å­˜æ³„æ¼æ£€æŸ¥

### Day 17: æ–‡æ¡£å’Œéƒ¨ç½²

#### ä»»åŠ¡æ¸…å•
- [ ] **ç”¨æˆ·æ–‡æ¡£**
  - ä½¿ç”¨æŒ‡å—
  - å¿«æ·é”®è¯´æ˜

- [ ] **å¼€å‘æ–‡æ¡£**
  - API æ–‡æ¡£
  - ç»´æŠ¤æŒ‡å—

- [ ] **éƒ¨ç½²å‡†å¤‡**
  - æ„å»ºä¼˜åŒ–
  - ç¯å¢ƒé…ç½®

### Day 18: å‘å¸ƒå’Œæ€»ç»“

#### ä»»åŠ¡æ¸…å•
- [ ] **å‘å¸ƒå‡†å¤‡**
  - ç‰ˆæœ¬å‘å¸ƒ
  - éƒ¨ç½²éªŒè¯

- [ ] **é¡¹ç›®æ€»ç»“**
  - åŠŸèƒ½éªŒæ”¶
  - æ–‡æ¡£æ•´ç†

- [ ] **åç»­è§„åˆ’**
  - åŠŸèƒ½è§„åˆ’
  - æ”¹è¿›å»ºè®®

---

## ğŸ“Š é¡¹ç›®ç®¡ç†å’Œè´¨é‡ä¿è¯

### ğŸ¯ æ¯æ—¥å·¥ä½œæµç¨‹

1. **æ™¨ä¼š (9:00-9:30)**
   - æ˜¨æ—¥å®Œæˆæƒ…å†µå›é¡¾
   - ä»Šæ—¥ä»»åŠ¡åˆ†é…
   - é˜»å¡é—®é¢˜è®¨è®º

2. **å¼€å‘æ—¶é—´ (9:30-17:30)**
   - æŒ‰ç…§ä»»åŠ¡æ¸…å•æ‰§è¡Œ
   - å®šæœŸä»£ç æäº¤
   - åŠæ—¶æ›´æ–°è¿›åº¦

3. **æ—¥ç»“ (17:30-18:00)**
   - å®Œæˆæƒ…å†µæ±‡æŠ¥
   - ä»£ç å®¡æŸ¥
   - æ˜æ—¥è®¡åˆ’ç¡®è®¤

### ğŸ“‹ è´¨é‡æ£€æŸ¥ç‚¹

#### ä»£ç è´¨é‡
- [ ] ESLint æ£€æŸ¥é€šè¿‡
- [ ] TypeScript ç±»å‹æ£€æŸ¥é€šè¿‡
- [ ] ä»£ç è¦†ç›–ç‡ > 80%
- [ ] æ€§èƒ½æŒ‡æ ‡æ»¡è¶³è¦æ±‚

#### åŠŸèƒ½è´¨é‡
- [ ] æ‰€æœ‰åŠŸèƒ½ç‚¹éªŒæ”¶é€šè¿‡
- [ ] ç”¨æˆ·ä½“éªŒæµç•…
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] å…¼å®¹æ€§æµ‹è¯•é€šè¿‡

### ğŸš¨ é£é™©ç®¡ç†

#### æŠ€æœ¯é£é™©
- **WebSocket è¿æ¥ç¨³å®šæ€§**
  - ç¼“è§£æªæ–½ï¼šå®Œå–„çš„é‡è¿æœºåˆ¶
  - åº”æ€¥æ–¹æ¡ˆï¼šé™çº§åˆ°è½®è¯¢æ¨¡å¼

- **å¤šæ ‡ç­¾é¡µå†…å­˜é—®é¢˜**
  - ç¼“è§£æªæ–½ï¼šä¼˜åŒ–å†…å­˜ç®¡ç†
  - åº”æ€¥æ–¹æ¡ˆï¼šé™åˆ¶æœ€å¤§æ ‡ç­¾é¡µæ•°

- **ç»„ä»¶é›†æˆå¤æ‚åº¦**
  - ç¼“è§£æªæ–½ï¼šå……åˆ†çš„å•å…ƒæµ‹è¯•
  - åº”æ€¥æ–¹æ¡ˆï¼šåˆ†é˜¶æ®µå‘å¸ƒ

#### è¿›åº¦é£é™©
- **ä»»åŠ¡ä¼°ç®—åå·®**
  - ç¼“è§£æªæ–½ï¼šæ¯æ—¥è¿›åº¦è·Ÿè¸ª
  - åº”æ€¥æ–¹æ¡ˆï¼šè°ƒæ•´åŠŸèƒ½èŒƒå›´

- **ä¾èµ–ç»„ä»¶å˜æ›´**
  - ç¼“è§£æªæ–½ï¼šç‰ˆæœ¬é”å®š
  - åº”æ€¥æ–¹æ¡ˆï¼šå¿«é€Ÿé€‚é…

### ğŸ“ˆ æˆåŠŸæŒ‡æ ‡

#### æŠ€æœ¯æŒ‡æ ‡
- [ ] æ”¯æŒåŒæ—¶æ‰“å¼€ 10+ ä¸ªæ ‡ç­¾é¡µ
- [ ] é¡µé¢å“åº”æ—¶é—´ < 200ms
- [ ] å†…å­˜ä½¿ç”¨å¢é•¿ < 10MB/å°æ—¶
- [ ] è¿æ¥æˆåŠŸç‡ > 95%

#### ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- [ ] æ“ä½œå“åº”æµç•…
- [ ] é”™è¯¯æ¢å¤åŠæ—¶
- [ ] ç•Œé¢ç›´è§‚æ˜“ç”¨
- [ ] åŠŸèƒ½å®Œæ•´å¯ç”¨

---

## ğŸ“ æ”¯æŒå’Œè”ç³»

### æŠ€æœ¯æ”¯æŒ
- å¼€å‘å›¢é˜Ÿï¼šdaily standup
- æŠ€æœ¯è¯„å®¡ï¼šæ¯å‘¨ä¸‰
- é—®é¢˜è¿½è¸ªï¼šGitHub Issues

### é¡¹ç›®åè°ƒ
- é¡¹ç›®è¿›åº¦ï¼šæ¯æ—¥æ±‡æŠ¥
- éœ€æ±‚å˜æ›´ï¼šå˜æ›´å§”å‘˜ä¼š
- é£é™©ç®¡ç†ï¼šé£é™©è¯„ä¼°ä¼šè®®

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-07-17  
**é¢„è®¡å®Œæˆ**: 2025-08-08  
**è´Ÿè´£äºº**: å‰ç«¯å¼€å‘å›¢é˜Ÿ  
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸