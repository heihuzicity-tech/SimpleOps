# 审计日志优化方案

## 问题分析

当前所有审计日志表（LoginLog、OperationLog、SessionRecord、CommandLog）都使用了 GORM 的软删除功能（`gorm.DeletedAt`），这会导致：

1. **存储空间问题**：
   - 数据永远不会真正删除，占用空间持续增长
   - 对于高频操作的堡垒机系统，日志量会非常大

2. **性能问题**：
   - 随着数据量增加，查询性能会下降
   - 索引效率降低

3. **业务逻辑问题**：
   - 审计日志的删除通常是为了满足合规要求（如保留90天）
   - 软删除对审计日志意义不大，审计日志删除后不需要恢复

## 解决方案

### 方案一：改为物理删除（推荐）

#### 1. 移除软删除字段

```sql
-- 从审计日志表中移除 deleted_at 字段
ALTER TABLE login_logs DROP COLUMN deleted_at;
ALTER TABLE operation_logs DROP COLUMN deleted_at;
ALTER TABLE session_records DROP COLUMN deleted_at;
ALTER TABLE command_logs DROP COLUMN deleted_at;
```

#### 2. 修改模型定义

```go
// 移除 DeletedAt 字段
type CommandLog struct {
    ID        uint       `json:"id" gorm:"primaryKey"`
    // ... 其他字段
    CreatedAt time.Time  `json:"created_at"`
    UpdatedAt time.Time  `json:"updated_at"`
    // DeletedAt gorm.DeletedAt `json:"-" gorm:"index"` // 移除此行
}
```

#### 3. 实现定期清理任务

```go
// 定期清理过期的审计日志
func CleanupExpiredAuditLogs() {
    cutoff := time.Now().AddDate(0, 0, -config.GlobalConfig.Audit.RetentionDays)
    
    // 物理删除过期日志
    db.Unscoped().Where("created_at < ?", cutoff).Delete(&models.CommandLog{})
    db.Unscoped().Where("created_at < ?", cutoff).Delete(&models.OperationLog{})
    // ... 其他日志表
}
```

### 方案二：分表归档策略

#### 1. 按月分表

```sql
-- 创建月度分表
CREATE TABLE command_logs_202501 LIKE command_logs;
CREATE TABLE command_logs_202502 LIKE command_logs;
```

#### 2. 实现自动分表逻辑

```go
func GetCommandLogTable() string {
    return fmt.Sprintf("command_logs_%s", time.Now().Format("200601"))
}
```

#### 3. 定期归档和清理

```go
// 归档旧数据到冷存储
func ArchiveOldLogs() {
    // 导出超过30天的数据到文件
    // 删除已归档的数据
}
```

### 方案三：混合方案

1. **近期数据**（30天内）：保留在主表，使用物理删除
2. **历史数据**（30-90天）：迁移到归档表
3. **过期数据**（>90天）：导出后物理删除

## 实施建议

### 第一阶段：移除软删除（1-2天）
1. 创建数据库迁移脚本
2. 修改模型定义
3. 更新相关的 Service 方法
4. 测试删除功能

### 第二阶段：实现定期清理（2-3天）
1. 创建定时任务框架
2. 实现清理逻辑
3. 添加清理日志和监控

### 第三阶段：优化查询性能（可选）
1. 添加分区表支持
2. 优化索引策略
3. 实现数据归档功能

## 影响范围

### 需要修改的文件：
1. **模型文件**：
   - `/backend/models/user.go` - 所有审计日志模型

2. **服务文件**：
   - `/backend/services/audit_service.go` - 删除方法需要使用 Unscoped()

3. **数据库迁移**：
   - 新增迁移文件移除 deleted_at 列

### API 兼容性：
- 对外 API 不受影响
- 内部删除逻辑需要调整

## 性能收益

1. **存储空间**：可以真正释放已删除数据的空间
2. **查询性能**：减少数据量，提高查询效率
3. **维护成本**：简化数据管理逻辑

## 风险评估

1. **数据恢复**：物理删除后无法恢复（可通过备份解决）
2. **误删风险**：需要严格的权限控制
3. **迁移风险**：需要在测试环境充分测试

## 结论

建议采用**方案一：物理删除 + 定期清理**，原因：
1. 实现简单，改动最小
2. 符合审计日志的实际使用场景
3. 可以有效解决存储和性能问题

如果未来有更高要求，可以升级到方案二或方案三。