# 命令审计功能已知问题

## 更新时间
2025-01-31

## 严重问题：历史命令绕过安全检查

### 问题描述
当用户通过上下键浏览并执行历史命令时，命令过滤机制会被绕过，危险命令可以被执行。

### 复现步骤
1. 手动输入危险命令（如 `rm -rf /`）- 会被正确拦截
2. 按上键调出历史命令中的 `rm` 命令
3. 按回车执行 - 命令会被执行而不被拦截

### 问题原因
1. **输入流处理机制**：
   - 手动输入：每个字符都经过 `updateCommandBuffer` 方法，命令被正确记录
   - 历史命令：用户按上键发送 `\x1b[A`，SSH 服务器返回完整的历史命令到输出流
   - 命令缓冲区为空，导致检查机制失效

2. **技术细节**：
   ```
   用户输入流程：
   手动输入 "rm" → updateCommandBuffer("r") → updateCommandBuffer("m") → 缓冲区="rm"
   
   历史命令流程：
   按上键 → 发送"\x1b[A" → SSH服务器返回"rm" → 显示在终端 → 缓冲区=""
   ```

### 影响范围
- 所有使用历史命令功能的场景
- 影响命令过滤的安全性
- 可能导致危险命令被执行

### 临时缓解措施
1. 禁用 SSH 会话的历史命令功能
2. 加强用户权限管理
3. 监控审计日志，及时发现异常

## 其他已知问题

### 1. 命令缓冲区管理
- Tab 补全的命令可能不完整
- 多行命令的处理不够完善
- 快速输入时可能丢失字符

### 2. 审计日志相关
- 录屏文件路径可能不匹配
- 历史数据的 action 字段为空（已通过数据库迁移解决）

## 建议的解决方案

### 方案一：输出流解析（复杂度高）
从 SSH 输出流中解析当前行的内容，提取实际要执行的命令。

**实现思路**：
1. 监听 SSH 输出流
2. 解析终端控制序列
3. 提取当前行内容作为待执行命令
4. 在回车时进行安全检查

**挑战**：
- 需要处理各种终端控制序列
- 不同 shell 的输出格式不同
- 性能开销较大

### 方案二：服务器端拦截（推荐）
在 SSH 服务器端实现命令拦截，而不是在 WebSocket 代理层。

**实现思路**：
1. 使用 PTY（伪终端）包装 SSH 会话
2. 在 PTY 层拦截所有命令
3. 实现命令审计和过滤

**优势**：
- 无法绕过
- 实现更可靠
- 可以拦截所有命令执行

### 方案三：禁用历史命令（影响体验）
通过配置禁用 SSH 会话的历史命令功能。

**实现方式**：
- 设置 `HISTSIZE=0`
- 或在用户 profile 中禁用历史

**缺点**：
- 严重影响用户体验
- 可能被用户绕过

## 相关文件
- `/backend/controllers/ssh_controller.go` - WebSocket 处理和命令拦截逻辑
- `/backend/services/ssh_service.go` - SSH 会话管理
- `updateCommandBuffer` 方法 - 命令缓冲区管理
- `getCommandFromBuffer` 方法 - 获取待检查的命令

## 下次会话需要
1. 决定采用哪种解决方案
2. 实现选定方案的具体代码
3. 测试各种边界情况
4. 更新相关文档

## 注意事项
这是一个严重的安全问题，需要尽快修复。在修复之前，建议：
1. 加强对高权限用户的监控
2. 定期审查命令日志
3. 考虑临时禁用历史命令功能