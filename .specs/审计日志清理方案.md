# 审计日志清理方案

## 背景
由于移除了批量删除功能和软删除机制，需要提供合理的数据清理方案。

## 方案一：数据库定期维护脚本

### 1. 创建清理脚本
```bash
#!/bin/bash
# cleanup_audit_logs.sh

# 配置
DB_HOST="10.0.0.7"
DB_USER="root"
DB_PASS="password123"
DB_NAME="bastion"
RETENTION_DAYS=90

# 清理函数
cleanup_logs() {
    local table=$1
    local days=$2
    
    echo "Cleaning $table older than $days days..."
    
    mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "
        DELETE FROM $table 
        WHERE created_at < DATE_SUB(NOW(), INTERVAL $days DAY);
    "
    
    # 获取删除的行数
    DELETED_ROWS=$(mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -se "SELECT ROW_COUNT();")
    echo "Deleted $DELETED_ROWS rows from $table"
}

# 备份当前数据
echo "Backing up audit logs..."
mysqldump -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME \
    command_logs operation_logs session_records login_logs \
    > audit_backup_$(date +%Y%m%d_%H%M%S).sql

# 清理各类日志
cleanup_logs "login_logs" $RETENTION_DAYS
cleanup_logs "operation_logs" $RETENTION_DAYS
cleanup_logs "session_records" $RETENTION_DAYS

# 命令日志特殊处理：保留高风险命令
echo "Cleaning command logs (preserving high-risk commands)..."
mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "
    DELETE FROM command_logs 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL $RETENTION_DAYS DAY)
    AND risk != 'high';
"

# 优化表
echo "Optimizing tables..."
mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "
    OPTIMIZE TABLE login_logs, operation_logs, session_records, command_logs;
"

echo "Cleanup completed!"
```

### 2. 使用 crontab 定期执行
```bash
# 每月1号凌晨3点执行清理
0 3 1 * * /path/to/cleanup_audit_logs.sh >> /var/log/audit_cleanup.log 2>&1
```

## 方案二：管理员API接口（安全可控）

### 1. 添加清理API路由
```go
// router.go
audit.POST("/cleanup", 
    middleware.RequirePermission("audit:admin"), 
    middleware.RequireSuperAdmin(), // 需要超级管理员权限
    auditController.CleanupAuditLogs)
```

### 2. 实现控制器方法
```go
// audit_controller.go
func (ac *AuditController) CleanupAuditLogs(c *gin.Context) {
    var req struct {
        Type      string `json:"type" binding:"required,oneof=all login operation session command"`
        Days      int    `json:"days" binding:"required,min=30"`
        KeepHigh  bool   `json:"keep_high_risk"` // 是否保留高风险命令
        Confirm   string `json:"confirm" binding:"required,eq=DELETE"`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        utils.RespondWithValidationError(c, "Invalid request")
        return
    }

    // 二次确认
    if req.Confirm != "DELETE" {
        utils.RespondWithValidationError(c, "Please confirm by typing DELETE")
        return
    }

    // 记录操作
    user := c.MustGet("user").(*models.User)
    logrus.WithFields(logrus.Fields{
        "user":     user.Username,
        "type":     req.Type,
        "days":     req.Days,
        "keepHigh": req.KeepHigh,
    }).Warn("Audit logs cleanup initiated")

    // 执行清理
    deleted, err := ac.auditService.CleanupAuditLogsByType(
        req.Type, 
        req.Days, 
        req.KeepHigh,
    )
    if err != nil {
        utils.RespondWithError(c, 500, "Cleanup failed")
        return
    }

    utils.RespondWithData(c, gin.H{
        "message": "Cleanup completed",
        "deleted": deleted,
    })
}
```

### 3. 服务层实现
```go
// audit_service.go
func (a *AuditService) CleanupAuditLogsByType(logType string, days int, keepHighRisk bool) (int64, error) {
    cutoff := time.Now().AddDate(0, 0, -days)
    var result *gorm.DB

    switch logType {
    case "command":
        query := a.db.Unscoped().Where("created_at < ?", cutoff)
        if keepHighRisk {
            query = query.Where("risk != ?", "high")
        }
        result = query.Delete(&models.CommandLog{})
    case "login":
        result = a.db.Unscoped().Where("created_at < ?", cutoff).Delete(&models.LoginLog{})
    case "operation":
        result = a.db.Unscoped().Where("created_at < ?", cutoff).Delete(&models.OperationLog{})
    case "session":
        result = a.db.Unscoped().Where("created_at < ?", cutoff).Delete(&models.SessionRecord{})
    case "all":
        // 清理所有类型
        total := int64(0)
        for _, t := range []string{"login", "operation", "session", "command"} {
            deleted, err := a.CleanupAuditLogsByType(t, days, keepHighRisk)
            if err != nil {
                return total, err
            }
            total += deleted
        }
        return total, nil
    default:
        return 0, fmt.Errorf("unknown log type: %s", logType)
    }

    if result.Error != nil {
        return 0, result.Error
    }

    return result.RowsAffected, nil
}
```

## 方案三：数据归档策略

### 1. 创建归档表
```sql
-- 创建归档表（结构相同，但使用压缩引擎）
CREATE TABLE command_logs_archive LIKE command_logs;
ALTER TABLE command_logs_archive ENGINE=ARCHIVE;
```

### 2. 归档脚本
```bash
#!/bin/bash
# archive_audit_logs.sh

# 归档90天前的数据
mysql -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME -e "
    -- 插入到归档表
    INSERT INTO command_logs_archive 
    SELECT * FROM command_logs 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 90 DAY);
    
    -- 从主表删除
    DELETE FROM command_logs 
    WHERE created_at < DATE_SUB(NOW(), INTERVAL 90 DAY);
"
```

## 方案四：分区表自动管理

### 1. 改造为分区表
```sql
-- 将命令日志表改为按月分区
ALTER TABLE command_logs 
PARTITION BY RANGE (YEAR(created_at) * 100 + MONTH(created_at)) (
    PARTITION p202501 VALUES LESS THAN (202502),
    PARTITION p202502 VALUES LESS THAN (202503),
    PARTITION p202503 VALUES LESS THAN (202504),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

### 2. 定期删除旧分区
```sql
-- 删除3个月前的分区
ALTER TABLE command_logs DROP PARTITION p202501;
```

## 推荐实施方案

### 短期方案（立即可用）
1. 使用**方案一**的数据库脚本进行手动清理
2. 设置 crontab 定期执行

### 中期方案（1-2周实施）
1. 实现**方案二**的管理员API
2. 在前端添加超级管理员专用的清理界面
3. 添加操作审计和二次确认机制

### 长期方案（规划实施）
1. 采用**方案四**的分区表
2. 结合**方案三**的归档策略
3. 实现自动化的数据生命周期管理

## 安全建议

1. **权限控制**：清理操作仅限超级管理员
2. **操作审计**：所有清理操作必须记录
3. **数据备份**：清理前自动备份
4. **二次确认**：防止误操作
5. **保留策略**：
   - 高风险命令永久保留或延长保留期
   - 被阻断的命令（action=deny）延长保留期
   - 重要用户操作延长保留期

## 监控指标

```sql
-- 查看各表数据量
SELECT 
    'command_logs' as table_name,
    COUNT(*) as total_rows,
    MIN(created_at) as oldest_record,
    MAX(created_at) as newest_record,
    ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) as size_mb
FROM information_schema.tables t
JOIN command_logs c
WHERE t.table_name = 'command_logs'
UNION ALL
-- 重复其他表...
```

## 总结

1. **立即可用**：使用 SQL 脚本手动清理
2. **推荐实施**：开发管理员清理API，提供可控的清理能力
3. **最佳实践**：
   - 定期清理低风险日志
   - 永久保留高风险和被阻断的命令
   - 清理前必须备份
   - 所有清理操作要审计